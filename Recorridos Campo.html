<!--    BLOQUE 1: HTML + CSS principal
        BLOQUE 2: SVG con elementos fijos
        BLOQUE 3: JavaScript b√°sico (variables, listeners)
        BLOQUE 4: Funciones de actualizaci√≥n y dibujo
        BLOQUE 5: Recorrido aleatorio
        BLOQUE 6: Exportaci√≥n
-->




<!-- ******** INICIO BLOQUE 1: HTML + CSS ******** -->
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Recorridos de orientaci√≥n ‚Äî Versi√≥n con conos movibles</title>
<style>
  :root{ --violeta:#B03A94; --bg:#f7f7f9; --panel-bg:rgba(255,255,255,0.95) }
  body{
    font-family: "Segoe UI", sans-serif;
    margin:0;
    padding:1rem;
    display:flex;
    gap:1.5rem;
    align-items:flex-start;
    background: var(--bg);
  }
  #panel{
    width: 400px;
    background: var(--panel-bg);
    padding: 1.3rem;
    border-radius: 12px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
  }
  h2{ 
    margin: 0 0 0.9rem 0; 
    font-size: 1.3rem;
  }
  label{ 
    font-size: 1.1rem;
    margin-top: 0.9rem; 
    display: block;
  }
  input[type="text"], #listaConos, select { 
    width: 100%; 
    box-sizing: border-box; 
    padding: 9px 11px;
    margin-top: 8px;
    border-radius: 8px;
    border: 1px solid #ccc;
    font-size: 1.1rem;
  }
  .row { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
  .small { 
    padding: 9px 13px;
    font-size: 1.1rem;
    border-radius: 8px;
    border: 0;
    background: var(--violeta);
    color: #fff;
    cursor: pointer;
  }
  button{ 
    background: var(--violeta);
    color: #fff;
    border: 0;
    padding: 11px 15px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 1.1rem;
  }
  .btn-edicion {
    background: #e74c3c;
    margin-top: 8px;
  }
  svg{ 
    max-width:920px; 
    width:100%; 
    height:auto; 
    border:1px solid #ccc; 
    background:white; 
  }
  .cono-pointer{ cursor:pointer }
  .cono-selected{ stroke:#000; stroke-width:0.9; fill-opacity:0.85; }
  .cono-dragging { opacity: 0.7; }
  .cono-descartado { opacity: 0.4; fill: #999 !important; }
  hr{ border:0; border-top:1px solid #eee; margin:10px 0; }
  
  /* Campos de conos en grid 4x3 */
  #camposConos {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
    margin-top: 6px;
  }
  #camposConos input {
    padding: 6px 8px;
    font-size: 1rem;
    margin-top: 0;
  }
  
  /* Zona de descarte */
  .zona-descarte {
    fill: rgba(255, 0, 0, 0.1);
    stroke: rgba(255, 0, 0, 0.5);
    stroke-width: 1;
    stroke-dasharray: 4,4;
  }
</style>
</head>
<body>

  <div id="panel">
    <h2>Recorrido de orientaci√≥n</h2>
    <label>Introducir conos separados por comas</label>
    <input id="listaConos" placeholder="Ej: 42,39,58,62,33,40,52">
    <div class="row">
      <button class="small" onclick="aplicarLista()">Aplicar lista</button>
      <button class="small" onclick="borrarRecorrido()">Borrar recorrido</button>
      <button class="small" onclick="generarRecorridoAleatorio()" id="botonAleatorio">Recorrido aleatorio (7)</button>
      <button class="small" onclick="copiarNumerosRecorrido()">Copiar n√∫meros</button>
    </div>

    <label>Conos seleccionados (m√°x. 12)</label>
    <div id="camposConos">
      <input id="id1" type="text" oninput="actualizarRecorrido()" placeholder="1">
      <input id="id2" type="text" oninput="actualizarRecorrido()" placeholder="2">
      <input id="id3" type="text" oninput="actualizarRecorrido()" placeholder="3">
      <input id="id4" type="text" oninput="actualizarRecorrido()" placeholder="4">
      <input id="id5" type="text" oninput="actualizarRecorrido()" placeholder="5">
      <input id="id6" type="text" oninput="actualizarRecorrido()" placeholder="6">
      <input id="id7" type="text" oninput="actualizarRecorrido()" placeholder="7">
      <input id="id8" type="text" oninput="actualizarRecorrido()" placeholder="8">
      <input id="id9" type="text" oninput="actualizarRecorrido()" placeholder="9">
      <input id="id10" type="text" oninput="actualizarRecorrido()" placeholder="10">
      <input id="id11" type="text" oninput="actualizarRecorrido()" placeholder="11">
      <input id="id12" type="text" oninput="actualizarRecorrido()" placeholder="12">
    </div>



    <!-- Control del fondo (mover la imagen) - EN DESPLEGABLE -->
    <details style="margin-top: 12px; padding: 8px; background: #f8f9fa; border-radius: 6px;">
      <summary style="cursor: pointer; font-weight: bold; padding: 4px; font-size: 1.5rem; display: flex; align-items: center; gap: 8px;">
        <span>üåÖ</span>
        <span>Ajustar fondo</span>
      </summary>
      
      <div class="row" style="margin-top:8px; align-items:center;">
        <label for="toggleFondo" style="margin:0">Mostrar fondo (Fondo_campo.png/jpg/jpeg/gif/webp/svg/pdf)</label>
        <input id="toggleFondo" type="checkbox" disabled>      
      </div>

      <div style="margin: 8px 0; font-size: 0.9rem; color: #666;">
        Mueve y haz zoom en la imagen de fondo para alinearla con los conos
      </div>
      
      <div id="controlesFondo" style="margin:10px 0;">
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <label style="flex: 1; min-width: 100px;">Escala fondo:</label>
          <div style="display: flex; align-items: center; gap: 4px; flex: 2;">
            <button onclick="ajustarEscala(-0.01)" style="padding:4px 8px;">-</button>
            <input type="range" id="sliderEscalaFondo" min="0.1" max="5" step="0.001" value="1" style="flex: 1;">
            <button onclick="ajustarEscala(0.01)" style="padding:4px 8px;">+</button>
            <span id="valorEscalaFondo" style="min-width: 40px; text-align: center;">1x</span>
          </div>
        </div>
        
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <label style="flex: 1; min-width: 100px;">Desplazar X:</label>
          <div style="display: flex; align-items: center; gap: 4px; flex: 2;">
            <button onclick="ajustarPosicion('X', -1)" style="padding:4px 8px;">‚Üê</button>
            <input type="range" id="sliderXFondo" min="-400" max="400" step="0.5" value="0" style="flex: 1;">
            <button onclick="ajustarPosicion('X', 1)" style="padding:4px 8px;">‚Üí</button>
            <span id="valorXFondo" style="min-width: 40px; text-align: center;">0</span>
          </div>
        </div>
        
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <label style="flex: 1; min-width: 100px;">Desplazar Y:</label>
          <div style="display: flex; align-items: center; gap: 4px; flex: 2;">
            <button onclick="ajustarPosicion('Y', -1)" style="padding:4px 8px;">‚Üë</button>
            <input type="range" id="sliderYFondo" min="-400" max="400" step="0.5" value="0" style="flex: 1;">
            <button onclick="ajustarPosicion('Y', 1)" style="padding:4px 8px;">‚Üì</button>
            <span id="valorYFondo" style="min-width: 40px; text-align: center;">0</span>
          </div>
        </div>
        
        <div style="text-align: center; margin-top: 12px;">
          <button onclick="resetearFondo()" class="small" style="padding:6px 12px;">
            ‚Üª Resetear posici√≥n fondo
          </button>
        </div>
      </div>
    </details>
    
    <hr>    



    <!-- Panel de configuraci√≥n desplegable -->
    <details style="margin-top: 12px; padding: 8px; background: #f8f9fa; border-radius: 6px;">
      <summary style="cursor: pointer; font-weight: bold; padding: 4px; font-size: 1.5rem; display: flex; align-items: center; gap: 8px;">
        <span>‚öôÔ∏è</span>
        <span>Configuraci√≥n avanzada</span>
      </summary>

      <div style="margin-top: 8px;">
        <label>N√∫mero de puntos: <span id="valorPuntos">7</span></label>
        <input type="range" id="numeroPuntos" min="5" max="12" step="1" value="7" onchange="actualizarNumeroPuntos()" style="width: 100%;">
      </div>

      <div style="margin-top: 8px;">
        <label>Grosor l√≠neas (1.3): <span id="valorGrosor">1.3</span>mm</label>
        <input type="range" id="grosorLineas" min="0.5" max="2.5" step="0.1" value="1.3" onchange="actualizarConfiguracion()" style="width: 100%;">
      </div>
      
      <div style="margin-top: 8px;">
        <label>Grosor bordes conos (0.2): <span id="valorBordeConos">0.2</span>mm</label>
        <input type="range" id="grosorBordeConos" min="0.1" max="1" step="0.1" value="0.2" onchange="actualizarConfiguracion()" style="width: 100%;">
      </div>
      
      <div style="margin-top: 8px;">
        <label>Tama√±o conos (3.5): <span id="valorConos">3.5</span>mm</label>
        <input type="range" id="tamanoConos" min="2" max="6" step="0.5" value="3.5" onchange="actualizarConfiguracion()" style="width: 100%;">
      </div>
      
      <div style="margin-top: 8px;">
        <label>Radio c√≠rculos (8): <span id="valorOverlay">8</span>mm</label>
        <input type="range" id="radioOverlay" min="5" max="12" step="0.5" value="8" onchange="actualizarConfiguracion()" style="width: 100%;">
      </div>
      
      <div style="margin-top: 8px;">
        <label>Tama√±o texto n√∫meros (9): <span id="valorTexto">9</span>px</label>
        <input type="range" id="tamanoTexto" min="6" max="12" step="0.5" value="9" onchange="actualizarConfiguracion()" style="width: 100%;">
      </div>

      <!-- Control para tama√±o de cuadr√≠cula -->
      <div style="margin-top: 8px;">
        <label>Tama√±o cuadr√≠cula (10): <span id="valorCuadricula">10</span>px</label>
        <input type="range" id="tamanoCuadricula" min="5" max="20" step="5" value="10" onchange="actualizarCuadricula()" style="width: 100%;">
      </div>

    <!-- Selector de forma de conos -->
    <div style="margin-top: 8px;">
      <label>Forma de los conos: </label>
      <select id="formaConos" onchange="cambiarFormaConos()" style="width: 100%; padding: 6px; margin-top: 4px;">
        <option value="circulo">C√≠rculo</option>
        <option value="x">X</option>
      </select>
    </div>

    </details>

    <hr>

    <h2 style="margin-top:12px; font-size:1.2rem">Exportar a SVG</h2>
    <div class="row">
      <label>Nombre del recorrido</label>
      <input id="nombre" placeholder="Ej: Recorrido_A">
      <button class="small" onclick="exportarSVGConIDs()">SVG con IDs</button>
      <button class="small" onclick="exportarSVG()">Exportar a SVG</button>
      <button class="small" onclick="exportarmediano()">SVG Mediano</button>
      <button class="small" onclick="exportarpeque()">SVG Peque√±o</button>
    </div>


    <!-- Bot√≥n de modo edici√≥n separado -->
    <hr style="margin: 16px 0;">
    <h2 style="margin: 0 0 8px 0; font-size:1.2rem; color: #e74c3c;">Modo Edici√≥n</h2>
    <div class="row">
      <button class="small btn-edicion" onclick="toggleModoEdicion()" id="toggleEdicion">Activar modo edici√≥n</button>
    </div>

    <!-- Botones para resetear conos -->
    <div class="row" style="margin-top: 8px;">
      <button class="small" onclick="excluirTodosConos()">Excluir todos los conos</button>
      <button class="small" onclick="resetearConos()">Resetear conos</button>
    </div>

    <!-- Sistema de guardado de posiciones -->
    <hr style="margin: 16px 0;">
    <h2 style="margin: 0 0 8px 0; font-size:1.2rem; color: #3498db;">Posiciones Guardadas</h2>

    <div style="margin-top: 8px;">
      <input type="text" id="nombreConfiguracion" placeholder="Nombre para guardar" style="width: 100%; padding: 8px; margin-bottom: 8px;">
    </div>

    <div class="row">
      <button class="small" onclick="guardarPosiciones()" style="background: #2ecc71;">Guardar posiciones</button>
      <button class="small" onclick="cargarPosiciones()" style="background: #3498db;">Cargar posiciones</button>
      <button class="small" onclick="eliminarConfiguracion()" style="background: #e74c3c;">Eliminar</button>
    </div>

    <div style="margin-top: 8px;">
      <label>Configuraciones guardadas:</label>
      <select id="selectorConfiguraciones" style="width: 100%; padding: 6px; margin-top: 4px;" onchange="seleccionarConfiguracion()">
        <option value="">-- Seleccionar --</option>
      </select>
    </div>

    <div style="font-size: 1.2rem; color: #666; margin-top: 8px;">
      En modo edici√≥n: Arrastra conos para moverlos. Los conos en zonas rojas no se exportan.
    </div>
  </div>
<!-- ******** FIN BLOQUE 1 ******** -->





















<!-- ******** INICIO BLOQUE 2: SVG Fijo ******** -->
  <!-- SVG con lienzo de 200x400mm (proporci√≥n 1:2) -->
  <svg id="mapa" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 400" width="800">
    <!-- Imagen de fondo dentro del SVG -->
    <g id="fondoGroup">
      <image id="bgImage" x="0" y="0" width="200" height="400" opacity="0.45" preserveAspectRatio="xMidYMid meet" />
    </g>
    <!-- Zonas de descarte (superior e inferior) -->
    <rect class="zona-descarte" x="0" y="0" width="200" height="50" style="display:none;"/>
    <rect class="zona-descarte" x="0" y="350" width="200" height="50" style="display:none;"/>
    
    <g id="fixed-layer">
      <!-- Doble c√≠rculo central en la parte superior -->
      <circle cx="100" cy="25" r="8" stroke="#B03A94" stroke-width="1.3" fill="none" id="circuloExterior"/>
      <circle cx="100" cy="25" r="5.4" stroke="#B03A94" stroke-width="1.3" fill="none" id="circuloInterior"/>

      <!-- Tri√°ngulo √∫nico en la parte inferior -->
      <polygon points="91.25,382.95 100,368.95 108.75,382.95" stroke="#B03A94" stroke-width="1.3" fill="none"/>
      
      <!-- Conos distribuidos en el √°rea permitida -->
      <!-- Fila 1 -->
      <circle id="cono24" cx="25" cy="80" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono51" cx="50" cy="80" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono91" cx="75" cy="80" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono29" cx="125" cy="80" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono79" cx="150" cy="80" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono62" cx="175" cy="80" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>

      <!-- Fila 2 -->
      <circle id="cono30" cx="25" cy="120" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono70" cx="50" cy="120" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono40" cx="75" cy="120" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono45" cx="125" cy="120" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono18" cx="150" cy="120" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono85" cx="175" cy="120" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>

      <!-- Fila 3 -->
      <circle id="cono55" cx="25" cy="160" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono15" cx="50" cy="160" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono96" cx="75" cy="160" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono68" cx="125" cy="160" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono39" cx="150" cy="160" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono33" cx="175" cy="160" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>

      <!-- Fila 4 -->
      <circle id="cono27" cx="25" cy="200" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono82" cx="50" cy="200" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono59" cx="75" cy="200" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono31" cx="125" cy="200" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono76" cx="150" cy="200" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono64" cx="175" cy="200" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>

      <!-- Fila 5 -->
      <circle id="cono48" cx="25" cy="240" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono13" cx="50" cy="240" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono89" cx="75" cy="240" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono52" cx="125" cy="240" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono11" cx="150" cy="240" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono94" cx="175" cy="240" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>

      <!-- Fila 6 -->
      <circle id="cono71" cx="25" cy="280" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono37" cx="50" cy="280" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono22" cx="75" cy="280" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono73" cx="125" cy="280" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono43" cx="150" cy="280" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono87" cx="175" cy="280" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
    </g>

    <!-- Capas din√°micas encima -->
    <g id="lineas"></g>
    <g id="recorrido"></g>
    <g id="numeros"></g>
  </svg>
<!-- ******** FIN BLOQUE 2 ******** -->






















<!-- ******** INICIO BLOQUE 3: Variables y Listeners ******** -->
<script>
// Variables globales para configuraci√≥n
let GROSOR_LINEAS = 1.3;
let GROSOR_BORDE_CONOS = 0.2;
let TAMANO_CONOS = 3.5;
let RADIO_OVERLAY = 8;
let TAMANO_TEXTO = 9;
let TAMANO_CUADRICULA = 10;
let NUMERO_PUNTOS = 7;

// Variable para forma de conos
let FORMA_CONOS = 'circulo'; // 'circulo' o 'x'

// Variables para el modo de edici√≥n
let modoEdicion = false;
let conoArrastrando = null;
let offsetX = 0;
let offsetY = 0;

// Sistema de configuraciones guardadas
let configuracionesGuardadas = JSON.parse(localStorage.getItem('campoConfiguraciones')) || {};

// Zonas de descarte
const ZONAS_DESCARTE = [
  { x: 0, y: 0, width: 200, height: 50 },      // Superior
  { x: 0, y: 350, width: 200, height: 50 }     // Inferior
];

// √Årea permitida para conos (excluyendo zonas de descarte)
const AREA_PERMITIDA = {
  minX: 0,
  maxX: 200,
  minY: 50,    // Debajo de zona descarte superior
  maxY: 350    // Encima de zona descarte inferior
};

/* --- referencias --- */
const campos = Array.from({length:12}, (_,i)=>document.getElementById('id'+(i+1)));
const gLineas = document.getElementById('lineas');
const gRecorrido = document.getElementById('recorrido');
const gNumeros = document.getElementById('numeros');
const toggleFondo = document.getElementById('toggleFondo');
const bgImage = document.getElementById('bgImage');

/* --- buscar fondo.png/jpg y activar checkbox solo si existe --- */
(function probeBackground(){
  const formatos = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'pdf'];
  const baseName = 'Fondo_campo';
  
  function test(src){
    return new Promise(res=>{
      const img = new Image();
      img.onload = ()=>res(src);
      img.onerror = ()=>res(null);
      img.src = src + '?_=' + Date.now();
    });
  }
  
  Promise.all(formatos.map(ext => test(`${baseName}.${ext}`))).then(results => {
    const found = results.find(src => src !== null);
    if(found){
      bgImage.setAttribute('href', found);
      bgImage.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      toggleFondo.disabled = false;
      toggleFondo.addEventListener('change', ()=> {
        bgImage.style.display = toggleFondo.checked ? 'block' : 'none';
      });
    } else {
      toggleFondo.disabled = true;
    }
  });
})();

/* --- ayuda: comprobar duplicado en campos --- */
function estaSeleccionado(id){ return campos.some(c => c.value === String(id)); }

/* --- aplicar lista de coma (bot√≥n) --- */
function aplicarLista(){
  const lista = document.getElementById('listaConos').value.trim();
  if(!lista) return;
  const valores = lista.split(',').map(s=>s.trim()).filter(Boolean).slice(0, NUMERO_PUNTOS);
  campos.forEach((c,i)=> c.value = valores[i] || '');
  actualizarRecorrido();
}

/* --- a√±adir listeners a los conos --- */
function configurarConos() {
  document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(cono => {
    cono.classList.add('cono-pointer');
    
    // Eliminar listeners anteriores para evitar duplicados
    cono.removeEventListener('click', manejarClicCono);
    cono.removeEventListener('mousedown', iniciarArrastre);
    
    if (modoEdicion) {
      cono.addEventListener('mousedown', iniciarArrastre);
    } else {
      cono.addEventListener('click', manejarClicCono);
    }
  });
}

function manejarClicCono(event) {
  const cono = event.target;
  const id = cono.id.replace('cono','');
  if(estaSeleccionado(id)) return;
  const idx = campos.findIndex(c => !c.value && c.style.display !== 'none');
  if(idx === -1){ alert('Ya has seleccionado los ' + NUMERO_PUNTOS + ' conos m√°ximos.'); return; }
  campos[idx].value = id;
  actualizarRecorrido();
}

/* --- borrar recorrido y campos --- */
function borrarRecorrido(){
  campos.forEach(c=>c.value='');
  gLineas.innerHTML = '';
  gRecorrido.innerHTML = '';
  gNumeros.innerHTML = '';
  document.querySelectorAll('#fixed-layer circle[id^="cono"]').forEach(c=>c.classList.remove('cono-selected'));
}

/* --- Copiar IDs de conos del recorrido al portapapeles --- */
function copiarNumerosRecorrido() {
    const ids = campos.map(c => c.value.trim()).filter(Boolean);
    if (ids.length === 0) {
        alert('No hay recorrido para copiar');
        return;
    }
    
    const idsConos = ids.join('\t');
    
    navigator.clipboard.writeText(idsConos)
        .then(() => {
            alert(`IDs copiados: ${ids.join(', ')}`);
        })
        .catch(err => {
            console.error('Error al copiar: ', err);
            const textArea = document.createElement('textarea');
            textArea.value = idsConos;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            alert(`IDs copiados: ${ids.join(', ')}`);
        });
}

/* --- Actualizar n√∫mero de puntos --- */
function actualizarNumeroPuntos() {
    NUMERO_PUNTOS = parseInt(document.getElementById('numeroPuntos').value);
    document.getElementById('valorPuntos').textContent = NUMERO_PUNTOS;
    
    // Mostrar/ocultar campos seg√∫n el n√∫mero seleccionado
    for (let i = 1; i <= 12; i++) {
        const campo = document.getElementById('id' + i);
        if (campo) {
            campo.style.display = i <= NUMERO_PUNTOS ? 'block' : 'none';
            if (i > NUMERO_PUNTOS) campo.value = ''; // Limpiar campos ocultos
        }
    }
    
    // Si hay valores en campos visibles, actualizar el recorrido
    if (Array.from(campos).slice(0, NUMERO_PUNTOS).some(campo => campo.value)) {
        actualizarRecorrido();
    }
    actualizarBotonAleatorio();
}

/* --- Actualizar texto del bot√≥n aleatorio --- */
function actualizarBotonAleatorio() {
    const boton = document.getElementById('botonAleatorio');
    if (boton) {
        boton.textContent = 'Recorrido aleatorio (' + NUMERO_PUNTOS + ')';
    }
}




// Inicializar bot√≥n al cargar la p√°gina
actualizarBotonAleatorio();

// Funci√≥n para cambiar forma de conos
function cambiarFormaConos() {
  FORMA_CONOS = document.getElementById('formaConos').value;
  actualizarFormaConos();
  // Si hay recorrido, actualizar para que se vean los cambios
  if (Array.from(campos).slice(0, NUMERO_PUNTOS).some(campo => campo.value)) {
    actualizarRecorrido();
  }
}

// ========== CONTROL DEL FONDO  ==========
// Referencias a los controles del fondo
const fondoGroup = document.getElementById('fondoGroup');
const sliderEscala = document.getElementById('sliderEscalaFondo');
const sliderX = document.getElementById('sliderXFondo');
const sliderY = document.getElementById('sliderYFondo');
const valorEscala = document.getElementById('valorEscalaFondo');
const valorX = document.getElementById('valorXFondo');
const valorY = document.getElementById('valorYFondo');

// Variables para estado del fondo
let scaleFondo = 1;
let offsetXFondo = 0;
let offsetYFondo = 0;

// Funci√≥n para actualizar la transformaci√≥n del fondo
function actualizarTransformFondo() {
    if(!fondoGroup) return;
    
    // Obtener valores actuales de los sliders
    const escala = sliderEscala ? parseFloat(sliderEscala.value) : 1;
    const desplazamientoX = sliderX ? parseFloat(sliderX.value) : 0;
    const desplazamientoY = sliderY ? parseFloat(sliderY.value) : 0;
    
    // Actualizar variables globales
    scaleFondo = escala;
    offsetXFondo = desplazamientoX;
    offsetYFondo = desplazamientoY;
    
    // Calcular transformaci√≥n para 200x400 (centro en 100,200)
    const centerX = 100; // Centro horizontal del SVG (200/2)
    const centerY = 200; // Centro vertical del SVG (400/2)
    
    // Transformaci√≥n en 3 pasos (sistema centrado):
    // 1. translate(-centerX, -centerY): mover al origen
    // 2. scale(escala): escalar
    // 3. translate(centerX + offsetX, centerY + offsetY): volver al centro + desplazamiento
    const transform = `
        translate(${centerX + offsetXFondo}, ${centerY + offsetYFondo}) 
        scale(${scaleFondo}) 
        translate(${-centerX}, ${-centerY})
    `;
    
    fondoGroup.setAttribute('transform', transform);
    
    // Actualizar valores visibles
    if(valorEscala) valorEscala.textContent = scaleFondo.toFixed(2);
    if(valorX) valorX.textContent = offsetXFondo;
    if(valorY) valorY.textContent = offsetYFondo;
}

// Funciones para ajuste fino del fondo
function ajustarEscala(delta) {
    if(!sliderEscala) return;
    let value = parseFloat(sliderEscala.value) + delta;
    // Limitar al rango
    value = Math.max(parseFloat(sliderEscala.min), Math.min(parseFloat(sliderEscala.max), value));
    sliderEscala.value = value.toFixed(3); // 3 decimales
    // Disparar evento de cambio
    sliderEscala.dispatchEvent(new Event('input'));
}

function ajustarPosicion(eje, delta) {
    const slider = document.getElementById('slider' + eje + 'Fondo');
    if(!slider) return;
    let value = parseFloat(slider.value) + delta;
    // Limitar al rango
    value = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), value));
    slider.value = value.toFixed(1); // 1 decimal
    // Disparar evento de cambio
    slider.dispatchEvent(new Event('input'));
}

function resetearFondo() {
    if(sliderEscala) sliderEscala.value = 1;
    if(sliderX) sliderX.value = 0;
    if(sliderY) sliderY.value = 0;
    actualizarTransformFondo();
}

// Asignar listeners a los sliders
if(sliderEscala) {
    sliderEscala.addEventListener('input', actualizarTransformFondo);
}
if(sliderX) {
    sliderX.addEventListener('input', actualizarTransformFondo);
}
if(sliderY) {
    sliderY.addEventListener('input', actualizarTransformFondo);
}

// Inicializar posici√≥n del fondo
actualizarTransformFondo();
// ========== FIN CONTROL DEL FONDO ==========

// ******** FIN BLOQUE 3 ********
















// ******* INICIO BLOQUE 4: Funciones de Edici√≥n y Dibujo ********
// --- Excluir todos los conos (mover a zonas de descarte ordenados) --- 
function excluirTodosConos() {
  if (!modoEdicion) {
    alert('Activa el modo edici√≥n primero');
    return;
  }
  
  const conos = Array.from(document.querySelectorAll('#fixed-layer circle[id^="cono"]'));
  
  // Dividir en dos grupos
  const mitad = Math.ceil(conos.length / 2);
  const grupoIzquierdo = conos.slice(0, mitad);
  const grupoDerecho = conos.slice(mitad);
  
  // Configuraci√≥n de la cuadr√≠cula - DENTRO de la zona de descarte (y: 0-50)
  const columnas = 6; // 6 columnas por grupo
  const espacioX = 25;
  const espacioY = 12;
  const inicioY = 10;
  const margenLateral = 10;
  
  // Posicionar grupo izquierdo
  grupoIzquierdo.forEach((cono, index) => {
    const fila = Math.floor(index / columnas);
    const columna = index % columnas;
    
    const x = margenLateral + (columna * espacioX);
    const y = inicioY + (fila * espacioY);
    
    cono.setAttribute('cx', x);
    cono.setAttribute('cy', y);
    actualizarEstadoConoDescarte(cono);
  });
  
  // Posicionar grupo derecho
  grupoDerecho.forEach((cono, index) => {
    const fila = Math.floor(index / columnas);
    const columna = index % columnas;
    
    const x = 100 + margenLateral + (columna * espacioX);
    const y = inicioY + (fila * espacioY);
    
    cono.setAttribute('cx', x);
    cono.setAttribute('cy', y);
    actualizarEstadoConoDescarte(cono);
  });
  
  actualizarRecorrido();
}

/* --- Resetear conos a posici√≥n original --- */
function resetearConos() {
  // Posiciones originales (del BLOQUE 2)
  const posicionesOriginales = {
    // Fila 1
    '24': {x: 25, y: 80}, '51': {x: 50, y: 80}, '91': {x: 75, y: 80},
    '29': {x: 125, y: 80}, '79': {x: 150, y: 80}, '62': {x: 175, y: 80},
    
    // Fila 2
    '30': {x: 25, y: 120}, '70': {x: 50, y: 120}, '40': {x: 75, y: 120},
    '45': {x: 125, y: 120}, '18': {x: 150, y: 120}, '85': {x: 175, y: 120},
    
    // Fila 3
    '55': {x: 25, y: 160}, '15': {x: 50, y: 160}, '96': {x: 75, y: 160},
    '68': {x: 125, y: 160}, '39': {x: 150, y: 160}, '33': {x: 175, y: 160},
    
    // Fila 4
    '27': {x: 25, y: 200}, '82': {x: 50, y: 200}, '59': {x: 75, y: 200},
    '31': {x: 125, y: 200}, '76': {x: 150, y: 200}, '64': {x: 175, y: 200},
    
    // Fila 5
    '48': {x: 25, y: 240}, '13': {x: 50, y: 240}, '89': {x: 75, y: 240},
    '52': {x: 125, y: 240}, '11': {x: 150, y: 240}, '94': {x: 175, y: 240},
    
    // Fila 6
    '71': {x: 25, y: 280}, '37': {x: 50, y: 280}, '22': {x: 75, y: 280},
    '73': {x: 125, y: 280}, '43': {x: 150, y: 280}, '87': {x: 175, y: 280}
  };
  
  document.querySelectorAll('#fixed-layer circle[id^="cono"]').forEach(cono => {
    const id = cono.id.replace('cono', '');
    const pos = posicionesOriginales[id];
    if (pos) {
      cono.setAttribute('cx', pos.x);
      cono.setAttribute('cy', pos.y);
      actualizarEstadoConoDescarte(cono);
    }
  });
  
  actualizarRecorrido();
}

/* --- Funciones para arrastrar conos --- */
function iniciarArrastre(event) {
  if (!modoEdicion) return;
  
  conoArrastrando = event.target;
  const svg = document.getElementById('mapa');
  const puntoSVG = svg.createSVGPoint();
  
  puntoSVG.x = event.clientX;
  puntoSVG.y = event.clientY;
  const transformado = puntoSVG.matrixTransform(svg.getScreenCTM().inverse());
  
  offsetX = transformado.x - parseFloat(conoArrastrando.getAttribute('cx'));
  offsetY = transformado.y - parseFloat(conoArrastrando.getAttribute('cy'));
  
  conoArrastrando.classList.add('cono-dragging');
  
  document.addEventListener('mousemove', arrastrarCono);
  document.addEventListener('mouseup', soltarCono);
  event.preventDefault();
}

function arrastrarCono(event) {
  if (!conoArrastrando) return;
  
  const svg = document.getElementById('mapa');
  const puntoSVG = svg.createSVGPoint();
  
  puntoSVG.x = event.clientX;
  puntoSVG.y = event.clientY;
  const transformado = puntoSVG.matrixTransform(svg.getScreenCTM().inverse());
  
  let nuevaX = transformado.x - offsetX;
  let nuevaY = transformado.y - offsetY;
  
  // Ajustar a la cuadr√≠cula
  nuevaX = Math.round(nuevaX / TAMANO_CUADRICULA) * TAMANO_CUADRICULA;
  nuevaY = Math.round(nuevaY / TAMANO_CUADRICULA) * TAMANO_CUADRICULA;
  
  // Verificar l√≠mites (PERMITIR zonas de descarte)
  nuevaX = Math.max(0, Math.min(200, nuevaX));
  nuevaY = Math.max(0, Math.min(400, nuevaY));
  
  conoArrastrando.setAttribute('cx', nuevaX);
  conoArrastrando.setAttribute('cy', nuevaY);
  
  // Verificar si est√° en zona de descarte
  actualizarEstadoConoDescarte(conoArrastrando);
  
  // Actualizar recorrido si este cono est√° seleccionado
  const id = conoArrastrando.id.replace('cono', '');
  if (estaSeleccionado(id)) {
    actualizarRecorrido();
  }
}

function soltarCono() {
  if (conoArrastrando) {
    conoArrastrando.classList.remove('cono-dragging');
    conoArrastrando = null;
  }
  document.removeEventListener('mousemove', arrastrarCono);
  document.removeEventListener('mouseup', soltarCono);
}

/* --- Verificar si un cono est√° en zona de descarte --- */
function estaEnZonaDescarte(cono) {
  const cx = parseFloat(cono.getAttribute('cx'));
  const cy = parseFloat(cono.getAttribute('cy'));
  
  return ZONAS_DESCARTE.some(zona => 
    cx >= zona.x && cx <= zona.x + zona.width &&
    cy >= zona.y && cy <= zona.y + zona.height
  );
}

/* --- Actualizar estado visual del cono (normal/descartado) --- */
function actualizarEstadoConoDescarte(cono) {
  if (estaEnZonaDescarte(cono)) {
    cono.classList.add('cono-descartado');
  } else {
    cono.classList.remove('cono-descartado');
  }
}

/* --- Actualizar forma visual de todos los conos --- */
function actualizarFormaConos() {
  // Guardar las posiciones de TODOS los conos antes de cambiar
  const posiciones = [];
  
  document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(cono => {
    const id = cono.id.replace('cono', '');
    
    // Obtener posici√≥n actual (tanto para c√≠rculos como para paths)
    let cx, cy;
    
    if (cono.tagName === 'circle') {
      // Si es c√≠rculo, obtener cx y cy directamente
      cx = cono.getAttribute('cx');
      cy = cono.getAttribute('cy');
    } else if (cono.tagName === 'path') {
      // Si es path (X), usar los atributos data-cx y data-cy guardados
      cx = cono.getAttribute('data-cx');
      cy = cono.getAttribute('data-cy');
      // Si no existen, calcular desde el atributo 'd'
      if (!cx || !cy) {
        const d = cono.getAttribute('d');
        const puntos = d.split(' ');
        const primerPunto = puntos[0].replace('M', '').split(',');
        cx = parseFloat(primerPunto[0]) + 2.5;
        cy = parseFloat(primerPunto[1]) + 2.5;
      }
    }
    
    posiciones.push({id, cx, cy});
  });
  
  // Limpiar y recrear TODOS los conos
  const fixedLayer = document.getElementById('fixed-layer');
  
  // Eliminar todos los conos actuales
  document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(cono => {
    cono.remove();
  });
  
  // Crear todos los conos nuevos con la forma seleccionada
  posiciones.forEach(({id, cx, cy}) => {
    const nuevoCono = FORMA_CONOS === 'x' 
      ? crearConoX(id, cx, cy)
      : crearConoCirculo(id, cx, cy);
    
    fixedLayer.appendChild(nuevoCono);
  });
  
  // Reconfigurar listeners
  configurarConos();
  
  // Actualizar estado de descarte para los nuevos conos
  document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(cono => {
    actualizarEstadoConoDescarte(cono);
  });
}

/* --- Crear cono tipo X --- */
function crearConoX(id, cx, cy) {
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.id = 'cono' + id;
  const x = parseFloat(cx);
  const y = parseFloat(cy);
  
  // X con tama√±o FIJO
  const tama√±oFijo = 2.5;
  path.setAttribute('d', `M${x-tama√±oFijo},${y-tama√±oFijo} L${x+tama√±oFijo},${y+tama√±oFijo} M${x+tama√±oFijo},${y-tama√±oFijo} L${x-tama√±oFijo},${y+tama√±oFijo}`);
  path.setAttribute('stroke', 'black');
  path.setAttribute('stroke-width', '0.8');
  path.setAttribute('stroke-linecap', 'round');
  path.setAttribute('fill', 'none');
  path.classList.add('cono-pointer');
  
  // Guardar las coordenadas originales como atributos personalizados
  path.setAttribute('data-cx', x);
  path.setAttribute('data-cy', y);
  
  return path;
}

/* --- Crear cono tipo c√≠rculo --- */
function crearConoCirculo(id, cx, cy) {
  const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  circle.id = 'cono' + id;
  circle.setAttribute('cx', cx);
  circle.setAttribute('cy', cy);
  circle.setAttribute('r', TAMANO_CONOS);
  circle.setAttribute('fill', 'deepskyblue');
  circle.setAttribute('stroke', 'black');
  circle.setAttribute('stroke-width', '0.2');
  circle.classList.add('cono-pointer');
  return circle;
}

/* --- Toggle modo edici√≥n --- */
function toggleModoEdicion() {
  modoEdicion = !modoEdicion;
  const boton = document.getElementById('toggleEdicion');
  boton.textContent = modoEdicion ? 'Desactivar modo edici√≥n' : 'Activar modo edici√≥n';
  
  // Mostrar/ocultar zonas de descarte
  document.querySelectorAll('.zona-descarte').forEach(zona => {
    zona.style.display = modoEdicion ? 'block' : 'none';
  });
  
  // Actualizar estado de todos los conos
  document.querySelectorAll('#fixed-layer circle[id^="cono"]').forEach(cono => {
    actualizarEstadoConoDescarte(cono);
  });
  
  configurarConos();
}

/* --- Actualizar tama√±o de cuadr√≠cula --- */
function actualizarCuadricula() {
  TAMANO_CUADRICULA = parseInt(document.getElementById('tamanoCuadricula').value);
  document.getElementById('valorCuadricula').textContent = TAMANO_CUADRICULA;
}

/* --- actualizar configuraci√≥n --- */
function actualizarConfiguracion() {
    GROSOR_LINEAS = parseFloat(document.getElementById('grosorLineas').value);
    GROSOR_BORDE_CONOS = parseFloat(document.getElementById('grosorBordeConos').value);
    TAMANO_CONOS = parseFloat(document.getElementById('tamanoConos').value);
    RADIO_OVERLAY = parseFloat(document.getElementById('radioOverlay').value);
    TAMANO_TEXTO = parseFloat(document.getElementById('tamanoTexto').value);

    document.getElementById('valorGrosor').textContent = GROSOR_LINEAS;
    document.getElementById('valorBordeConos').textContent = GROSOR_BORDE_CONOS;
    document.getElementById('valorConos').textContent = TAMANO_CONOS;
    document.getElementById('valorOverlay').textContent = RADIO_OVERLAY;
    document.getElementById('valorTexto').textContent = TAMANO_TEXTO;

    // ACTUALIZAR overlays del recorrido (c√≠rculos alrededor de conos seleccionados)
    document.querySelectorAll('#recorrido circle').forEach(circ => {
        circ.setAttribute('r', RADIO_OVERLAY);
        circ.setAttribute('stroke-width', GROSOR_LINEAS);
    });

    // ACTUALIZAR bordes de los conos (tanto c√≠rculos como X)
    document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(cono => {
        if (cono.tagName === 'circle') {
            // Actualizar c√≠rculos
            cono.setAttribute('r', TAMANO_CONOS);
            cono.setAttribute('stroke-width', GROSOR_BORDE_CONOS);
        } else if (cono.tagName === 'path' && FORMA_CONOS === 'x') {
            // Actualizar X - recrear con nuevo tama√±o
            const id = cono.id.replace('cono', '');
            const tama√±oX = TAMANO_CONOS * 0.7;
            
            // Obtener posici√≥n actual
            let cx, cy;
            if (cono.hasAttribute('data-cx') && cono.hasAttribute('data-cy')) {
                cx = parseFloat(cono.getAttribute('data-cx'));
                cy = parseFloat(cono.getAttribute('data-cy'));
            } else {
                const d = cono.getAttribute('d');
                const puntos = d.split(' ');
                const primerPunto = puntos[0].replace('M', '').split(',');
                cx = parseFloat(primerPunto[0]) + 2.5;
                cy = parseFloat(primerPunto[1]) + 2.5;
            }
            
            // Crear nueva X con tama√±o actualizado
            const nuevaX = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            nuevaX.id = 'cono' + id;
            nuevaX.setAttribute('d', `M${cx-tama√±oX},${cy-tama√±oX} L${cx+tama√±oX},${cy+tama√±oX} M${cx+tama√±oX},${cy-tama√±oX} L${cx-tama√±oX},${cy+tama√±oX}`);
            nuevaX.setAttribute('stroke', 'black');
            nuevaX.setAttribute('stroke-width', '0.8');
            nuevaX.setAttribute('stroke-linecap', 'round');
            nuevaX.setAttribute('fill', 'none');
            nuevaX.classList.add('cono-pointer');
            nuevaX.setAttribute('data-cx', cx);
            nuevaX.setAttribute('data-cy', cy);
            
            // Reemplazar la X antigua
            cono.parentNode.replaceChild(nuevaX, cono);
        }
    });

    // ACTUALIZAR tama√±o de texto de los n√∫meros
    document.querySelectorAll('#numeros text').forEach(texto => {
        texto.setAttribute('font-size', TAMANO_TEXTO);
    });

    const circuloExt = document.getElementById('circuloExterior');
    const circuloInt = document.getElementById('circuloInterior');
    if (circuloExt && circuloInt) {
        circuloExt.setAttribute('r', RADIO_OVERLAY);
        circuloInt.setAttribute('r', RADIO_OVERLAY * 0.67);
    }

    document.querySelectorAll('#fixed-layer [stroke="#B03A94"]').forEach(el => {
        el.setAttribute('stroke-width', GROSOR_LINEAS);
    });

    document.querySelectorAll('#lineas line').forEach(linea => {
        linea.setAttribute('stroke-width', GROSOR_LINEAS);
    });

    // Forzar actualizaci√≥n completa del recorrido si hay conos seleccionados
    const tieneRecorrido = Array.from(campos).slice(0, NUMERO_PUNTOS).some(campo => campo.value);
    if (tieneRecorrido) {
        // Guardar el estado actual
        const valoresActuales = campos.map(c => c.value);
        
        // Limpiar temporalmente (esto activar√° actualizarRecorrido a trav√©s de los listeners)
        campos.forEach(c => c.value = '');
        
        // Restaurar inmediatamente en el siguiente ciclo de evento
        setTimeout(() => {
            campos.forEach((c, i) => {
                if (i < valoresActuales.length) c.value = valoresActuales[i];
            });
            // Forzar la actualizaci√≥n final
            actualizarRecorrido();
        }, 0);
    }
   configurarConos();
}

/* --- Funci√≥n para posicionar n√∫meros --- */
function posicionNumero(cono) {
    // Posici√≥n simple: arriba a la derecha del cono
    const SEPARACION = RADIO_OVERLAY + 2;
    return {dx: SEPARACION, dy: -SEPARACION};
}

/* --- Funci√≥n principal: actualizarRecorrido --- */
function actualizarRecorrido(){
    gLineas.innerHTML = '';
    gRecorrido.innerHTML = '';
    gNumeros.innerHTML = '';

    document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(c=>
        c.classList.remove('cono-selected')
    );

    const ids = campos.map(c=>c.value.trim()).filter(Boolean);

    const coords = ids.map(id=>{
        const el = document.getElementById('cono'+id);
        if(!el) return null;
        
        let x, y;
        
        if (el.tagName === 'circle') {
            // Si es c√≠rculo, obtener cx y cy directamente
            x = parseFloat(el.getAttribute('cx'));
            y = parseFloat(el.getAttribute('cy'));
        } else if (el.tagName === 'path') {
            // Si es path (X), usar data-cx y data-cy o calcular desde 'd'
            if (el.hasAttribute('data-cx') && el.hasAttribute('data-cy')) {
                x = parseFloat(el.getAttribute('data-cx'));
                y = parseFloat(el.getAttribute('data-cy'));
            } else {
                const d = el.getAttribute('d');
                const puntos = d.split(' ');
                const primerPunto = puntos[0].replace('M', '').split(',');
                x = parseFloat(primerPunto[0]) + 2.5;
                y = parseFloat(primerPunto[1]) + 2.5;
            }
        }
        
        return {
            id,
            x: x,
            y: y
        };
    }).filter(Boolean);

    // Dibujar overlays y n√∫meros
    coords.forEach((p,i)=>{
        const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circ.setAttribute('cx', p.x);
        circ.setAttribute('cy', p.y);
        circ.setAttribute('r', RADIO_OVERLAY);
        circ.setAttribute('stroke', '#B03A94');
        circ.setAttribute('fill', 'none');
        circ.setAttribute('stroke-width', GROSOR_LINEAS);
        gRecorrido.appendChild(circ);

        const {dx, dy} = posicionNumero(p);

        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.setAttribute('x', p.x + dx);
        txt.setAttribute('y', p.y + dy);
        txt.setAttribute('fill', '#B03A94');
        txt.setAttribute('font-size', TAMANO_TEXTO);
        txt.setAttribute('font-weight', '700');
        txt.setAttribute('text-anchor', 'middle');
        txt.setAttribute('dominant-baseline', 'middle');
        txt.textContent = String(i+1);
        gNumeros.appendChild(txt);

        const base = document.getElementById('cono'+p.id);
        if(base) base.classList.add('cono-selected');
    });

    // L√≠nea desde el tri√°ngulo de inicio al primer cono
    if(coords.length > 0){
        const pTri = {x:100, y:368.95}; // Punta del tri√°ngulo
        const first = coords[0];
        const dx = first.x - pTri.x;
        const dy = first.y - pTri.y;
        const d = Math.hypot(dx,dy) || 1;

        const x2 = first.x - (RADIO_OVERLAY * dx / d);
        const y2 = first.y - (RADIO_OVERLAY * dy / d);

        const l = document.createElementNS('http://www.w3.org/2000/svg','line');
        l.setAttribute('x1', pTri.x);
        l.setAttribute('y1', pTri.y);
        l.setAttribute('x2', x2);
        l.setAttribute('y2', y2);
        l.setAttribute('stroke', '#B03A94');
        l.setAttribute('stroke-width', GROSOR_LINEAS);
        l.setAttribute('stroke-linecap','round');
        gLineas.appendChild(l);
    }

    // L√≠neas entre conos
    for(let i=0;i<coords.length-1;i++){
        const a = coords[i], b = coords[i+1];
        const dx = b.x-a.x, dy = b.y-a.y;
        const d = Math.hypot(dx,dy) || 1;

        const ox = RADIO_OVERLAY * dx/d;
        const oy = RADIO_OVERLAY * dy/d;

        const x1 = a.x + ox;
        const y1 = a.y + oy;
        const x2 = b.x - ox;
        const y2 = b.y - oy;

        const l = document.createElementNS('http://www.w3.org/2000/svg','line');
        l.setAttribute('x1', x1);
        l.setAttribute('y1', y1);
        l.setAttribute('x2', x2);
        l.setAttribute('y2', y2);
        l.setAttribute('stroke', '#B03A94');
        l.setAttribute('stroke-width', GROSOR_LINEAS);
        l.setAttribute('stroke-linecap','round');
        gLineas.appendChild(l);
    }

    // L√≠nea final hacia el c√≠rculo central
    if(coords.length > 0){
        const last = coords[coords.length-1];
        const cx=100, cy=25; // Posici√≥n del c√≠rculo central
        const dx=cx-last.x, dy=cy-last.y;
        const d=Math.hypot(dx,dy) || 1;

        const x1 = last.x + (RADIO_OVERLAY * dx/d);
        const y1 = last.y + (RADIO_OVERLAY * dy/d);
        const x2 = cx - (RADIO_OVERLAY * dx/d);
        const y2 = cy - (RADIO_OVERLAY * dy/d);

        const lf = document.createElementNS('http://www.w3.org/2000/svg','line');
        lf.setAttribute('x1', x1);
        lf.setAttribute('y1', y1);
        lf.setAttribute('x2', x2);
        lf.setAttribute('y2', y2);
        lf.setAttribute('stroke', '#B03A94');
        lf.setAttribute('stroke-width', GROSOR_LINEAS);
        lf.setAttribute('stroke-linecap','round');
        gLineas.appendChild(lf);
    }
}

/* --- Sistema de guardado/carga de posiciones --- */

function guardarPosiciones() {
  if (!modoEdicion) {
    alert('Activa el modo edici√≥n primero');
    return;
  }
  
  const nombre = document.getElementById('nombreConfiguracion').value.trim();
  if (!nombre) {
    alert('Ingresa un nombre para la configuraci√≥n');
    return;
  }
  
  // Obtener todas las posiciones actuales
  const posiciones = {};
  document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(cono => {
    const id = cono.id.replace('cono', '');
    
    let cx, cy;
    
    if (cono.tagName === 'circle') {
      cx = parseFloat(cono.getAttribute('cx'));
      cy = parseFloat(cono.getAttribute('cy'));
    } else if (cono.tagName === 'path') {
      if (cono.hasAttribute('data-cx') && cono.hasAttribute('data-cy')) {
        cx = parseFloat(cono.getAttribute('data-cx'));
        cy = parseFloat(cono.getAttribute('data-cy'));
      } else {
        const d = cono.getAttribute('d');
        const puntos = d.split(' ');
        const primerPunto = puntos[0].replace('M', '').split(',');
        cx = parseFloat(primerPunto[0]) + 2.5;
        cy = parseFloat(primerPunto[1]) + 2.5;
      }
    }
    
    posiciones[id] = { cx: cx, cy: cy };
  });
  
  // Guardar tambi√©n la forma actual y otros datos
  const configuracion = {
    posiciones: posiciones,
    forma: FORMA_CONOS,
    fecha: new Date().toLocaleString(),
    recorrido: campos.map(c => c.value).filter(v => v),
    nombreRecorrido: document.getElementById('nombre').value
  };
  
  configuracionesGuardadas[nombre] = configuracion;
  localStorage.setItem('campoConfiguraciones', JSON.stringify(configuracionesGuardadas));
  
  // Actualizar selector
  actualizarSelectorConfiguraciones();
  alert(`Configuraci√≥n "${nombre}" guardada correctamente`);
}

function cargarPosiciones() {
  const selector = document.getElementById('selectorConfiguraciones');
  const nombre = selector.value;
  
  if (!nombre || !configuracionesGuardadas[nombre]) {
    alert('Selecciona una configuraci√≥n v√°lida');
    return;
  }
  
  const config = configuracionesGuardadas[nombre];
  
  // Activar modo edici√≥n si no est√° activo
  if (!modoEdicion) {
    toggleModoEdicion();
  }
  
  // Restaurar forma si es diferente
  if (config.forma && config.forma !== FORMA_CONOS) {
    FORMA_CONOS = config.forma;
    document.getElementById('formaConos').value = FORMA_CONOS;
    actualizarFormaConos();
  }
  
  // Aplicar posiciones
  Object.keys(config.posiciones).forEach(id => {
    const pos = config.posiciones[id];
    const cono = document.getElementById('cono' + id);
    
    if (cono) {
      if (cono.tagName === 'circle') {
        cono.setAttribute('cx', pos.cx);
        cono.setAttribute('cy', pos.cy);
      } else if (cono.tagName === 'path') {
        // Para X, actualizar atributos data-*
        cono.setAttribute('data-cx', pos.cx);
        cono.setAttribute('data-cy', pos.cy);
        // Recrear la X en la nueva posici√≥n
        const tama√±oX = 2.5; // Tama√±o fijo para X
        cono.setAttribute('d', `M${pos.cx-tama√±oX},${pos.cy-tama√±oX} L${pos.cx+tama√±oX},${pos.cy+tama√±oX} M${pos.cx+tama√±oX},${pos.cy-tama√±oX} L${pos.cx-tama√±oX},${pos.cy+tama√±oX}`);
      }
      actualizarEstadoConoDescarte(cono);
    }
  });
  
  // Restaurar recorrido si existe
  if (config.recorrido && config.recorrido.length > 0) {
    campos.forEach((c, i) => {
      c.value = config.recorrido[i] || '';
    });
  }
  
  // Restaurar nombre del recorrido
  if (config.nombreRecorrido) {
    document.getElementById('nombre').value = config.nombreRecorrido;
  }
  
  // Actualizar recorrido
  actualizarRecorrido();
  
  // Actualizar selector
  actualizarSelectorConfiguraciones();
  alert(`Configuraci√≥n "${nombre}" cargada`);
}

function actualizarSelectorConfiguraciones() {
  const selector = document.getElementById('selectorConfiguraciones');
  selector.innerHTML = '<option value="">-- Seleccionar --</option>';
  
  Object.keys(configuracionesGuardadas).sort().forEach(nombre => {
    const option = document.createElement('option');
    option.value = nombre;
    const fecha = configuracionesGuardadas[nombre].fecha || '';
    option.textContent = `${nombre} ${fecha ? `(${fecha})` : ''}`;
    selector.appendChild(option);
  });
}

function seleccionarConfiguracion() {
  const selector = document.getElementById('selectorConfiguraciones');
  const nombre = selector.value;
  
  if (nombre && configuracionesGuardadas[nombre]) {
    document.getElementById('nombreConfiguracion').value = nombre;
  }
}

function eliminarConfiguracion() {
  const nombre = document.getElementById('nombreConfiguracion').value.trim();
  
  if (!nombre || !configuracionesGuardadas[nombre]) {
    alert('No hay configuraci√≥n para eliminar');
    return;
  }
  
  if (confirm(`¬øEliminar permanentemente la configuraci√≥n "${nombre}"?`)) {
    delete configuracionesGuardadas[nombre];
    localStorage.setItem('campoConfiguraciones', JSON.stringify(configuracionesGuardadas));
    actualizarSelectorConfiguraciones();
    document.getElementById('nombreConfiguracion').value = '';
    alert(`Configuraci√≥n "${nombre}" eliminada`);
  }
}
// ******** FIN BLOQUE 4 ********





















// ******** INICIO BLOQUE 5: Recorrido Aleatorio ********
/* --- Generar recorrido aleatorio --- */
function generarRecorridoAleatorio() {
  const todosConos = Array.from(document.querySelectorAll('#fixed-layer circle[id^="cono"]'))
    .map(cono => cono.id.replace('cono', ''))
    .filter(id => {
      const cono = document.getElementById('cono' + id);
      return !estaEnZonaDescarte(cono); // Excluir conos en zona de descarte
    });
  
  // Mezclar array
  for (let i = todosConos.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [todosConos[i], todosConos[j]] = [todosConos[j], todosConos[i]];
  }
  
  // Tomar el n√∫mero especificado de conos
  const conosSeleccionados = todosConos.slice(0, NUMERO_PUNTOS);
  
  // Limpiar campos y aplicar nuevos valores
  campos.forEach(c => c.value = '');
  conosSeleccionados.forEach((id, index) => {
    if (index < campos.length) {
      campos[index].value = id;
    }
  });

  actualizarRecorrido();
}
// ******** FIN BLOQUE 5 ********






















// ******** INICIO BLOQUE 6: Exportaci√≥n ******** 
/* --- Exportar SVG Mediano (56%) --- */
function exportarmediano() {
    const SCALE = 0.56;

    const nombreInput = document.getElementById('nombre').value.trim();
    const nombre = nombreInput ? nombreInput + "_56" : "recorrido_56";

    const original = document.getElementById('mapa');

    const svgNS = "http://www.w3.org/2000/svg";
    const nuevo = document.createElementNS(svgNS, "svg");

    nuevo.setAttribute("width", (200 * SCALE) + "mm");
    nuevo.setAttribute("height", (400 * SCALE) + "mm");
    nuevo.setAttribute("viewBox", `0 0 ${200 * SCALE} ${400 * SCALE}`);

    function esc(n) { return parseFloat(n) * SCALE; }

    function copiarNodo(nodo, destinoPadre) {
        if (nodo.nodeType === 3) return;

        const clon = document.createElementNS(svgNS, nodo.nodeName);

        for (const attr of nodo.attributes || []) {
            let name = attr.name;
            let val = attr.value;

            if (name === "data-noexport") return;

            if (["cx","cy","x","y","r","x1","y1","x2","y2"].includes(name)) {
                clon.setAttribute(name, esc(val));
                continue;
            }

            if (name === "stroke-width") {
                if (nodo.id && nodo.id.startsWith("cono")) {
                    clon.setAttribute(name, esc(GROSOR_BORDE_CONOS));
                } else {
                    clon.setAttribute(name, esc(val));
                }
                continue;
            }

            if (name === "font-size") {
                clon.setAttribute(name, esc(val));
                continue;
            }

            if (name === "points") {
                const puntos = val.trim().split(" ").map(par => {
                    const [px, py] = par.split(",");
                    return esc(px) + "," + esc(py);
                });
                clon.setAttribute("points", puntos.join(" "));
                continue;
            }

            clon.setAttribute(name, val);
        }

        if (nodo.textContent && nodo.children.length === 0) {
            clon.textContent = nodo.textContent;
        }

        destinoPadre.appendChild(clon);

        for (const hijo of nodo.children) copiarNodo(hijo, clon);
    }

    const capas = ["fixed-layer", "lineas", "recorrido", "numeros"];

    capas.forEach(id => {
        const originalCapa = original.querySelector("#" + id);
        if (!originalCapa) return;

        const nuevaCapa = document.createElementNS(svgNS, "g");
        nuevaCapa.setAttribute("id", id);

        for (const nodo of originalCapa.children) {
            copiarNodo(nodo, nuevaCapa);
        }
        nuevo.appendChild(nuevaCapa);
    });

    const xml = new XMLSerializer().serializeToString(nuevo);
    const blob = new Blob([xml], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = nombre + ".svg";
    a.click();

    URL.revokeObjectURL(url);
}

/* --- Exportar SVG Peque√±o (40%) --- */
function exportarpeque() {
    const SCALE = 0.40;

    const nombreInput = document.getElementById('nombre').value.trim();
    const nombre = nombreInput ? nombreInput + "_40" : "recorrido_40";

    const original = document.getElementById('mapa');

    const svgNS = "http://www.w3.org/2000/svg";
    const nuevo = document.createElementNS(svgNS, "svg");

    nuevo.setAttribute("width", (200 * SCALE) + "mm");
    nuevo.setAttribute("height", (400 * SCALE) + "mm");
    nuevo.setAttribute("viewBox", `0 0 ${200 * SCALE} ${400 * SCALE}`);

    function esc(n) { return parseFloat(n) * SCALE; }

    function copiarNodo(nodo, destinoPadre) {
        if (nodo.nodeType === 3) return;

        const clon = document.createElementNS(svgNS, nodo.nodeName);

        for (const attr of nodo.attributes || []) {
            let name = attr.name;
            let val = attr.value;

            if (name === "data-noexport") return;

            if (["cx","cy","x","y","r","x1","y1","x2","y2"].includes(name)) {
                clon.setAttribute(name, esc(val));
                continue;
            }

            if (name === "stroke-width") {
                if (nodo.id && nodo.id.startsWith("cono")) {
                    clon.setAttribute(name, esc(GROSOR_BORDE_CONOS));
                } else {
                    clon.setAttribute(name, esc(val));
                }
                continue;
            }

            if (name === "font-size") {
                clon.setAttribute(name, esc(val));
                continue;
            }

            if (name === "points") {
                const puntos = val.trim().split(" ").map(par => {
                    const [px, py] = par.split(",");
                    return esc(px) + "," + esc(py);
                });
                clon.setAttribute("points", puntos.join(" "));
                continue;
            }

            clon.setAttribute(name, val);
        }

        if (nodo.textContent && nodo.children.length === 0) {
            clon.textContent = nodo.textContent;
        }

        destinoPadre.appendChild(clon);

        for (const hijo of nodo.children) copiarNodo(hijo, clon);
    }

    const capas = ["fixed-layer", "lineas", "recorrido", "numeros"];

    capas.forEach(id => {
        const originalCapa = original.querySelector("#" + id);
        if (!originalCapa) return;

        const nuevaCapa = document.createElementNS(svgNS, "g");
        nuevaCapa.setAttribute("id", id);

        for (const nodo of originalCapa.children) {
            copiarNodo(nodo, nuevaCapa);
        }
        nuevo.appendChild(nuevaCapa);
    });

    const xml = new XMLSerializer().serializeToString(nuevo);
    const blob = new Blob([xml], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = nombre + ".svg";
    a.click();

    URL.revokeObjectURL(url);
}

/* --- Funci√≥n de exportaci√≥n 100% --- */
function exportarSVG(){
  const nombreInput = document.getElementById('nombre').value.trim();
  const nombre = nombreInput ? nombreInput : 'recorrido';
  const original = document.getElementById('mapa');
  const clone = original.cloneNode(true);

  // Eliminar elementos no exportables
  clone.querySelectorAll('[data-noexport="true"]').forEach(n => n.remove());
  clone.querySelectorAll('.zona-descarte').forEach(n => n.remove());
  
  // Eliminar conos que est√©n en zona de descarte
  clone.querySelectorAll('circle[id^="cono"]').forEach(cono => {
    const cx = parseFloat(cono.getAttribute('cx'));
    const cy = parseFloat(cono.getAttribute('cy'));
    
    const enZonaDescarte = ZONAS_DESCARTE.some(zona => 
      cx >= zona.x && cx <= zona.x + zona.width &&
      cy >= zona.y && cy <= zona.y + zona.height
    );
    
    if (enZonaDescarte) {
      cono.remove();
    } else {
      cono.setAttribute('stroke-width', GROSOR_BORDE_CONOS);
    }
  });

  clone.setAttribute('width', '200mm');
  clone.setAttribute('height', '400mm');
  clone.setAttribute('viewBox', '0 0 200 400');

  const xml = new XMLSerializer().serializeToString(clone);
  const blob = new Blob([xml], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${nombre}.svg`;
  a.click();
  URL.revokeObjectURL(url);
}

/* --- Exportar SVG con TODOS los IDs de conos (para evaluaci√≥n) --- */
function exportarSVGConIDs() {
  const nombreInput = document.getElementById('nombre').value.trim();
  const nombre = nombreInput ? nombreInput + "_todosIDs" : "recorrido_todosIDs";
  const original = document.getElementById('mapa');
  const clone = original.cloneNode(true);
  
  // Eliminar elementos no exportables
  clone.querySelectorAll('[data-noexport="true"]').forEach(n => n.remove());
  clone.querySelectorAll('.zona-descarte').forEach(n => n.remove());
  
  // Array para almacenar posiciones de textos y evitar solapamientos
  const textosPosiciones = [];
  
  // Procesar TODOS los conos visibles (no en zonas de descarte)
  clone.querySelectorAll('[id^="cono"]').forEach(cono => {
    const id = cono.id.replace('cono', '');
    
    // Obtener posici√≥n del cono
    let cx, cy;
    
    if (cono.tagName === 'circle') {
      cx = parseFloat(cono.getAttribute('cx'));
      cy = parseFloat(cono.getAttribute('cy'));
      cono.setAttribute('stroke-width', GROSOR_BORDE_CONOS);
    } else if (cono.tagName === 'path') {
      // Para X, obtener posici√≥n desde data-* o calcular
      if (cono.hasAttribute('data-cx') && cono.hasAttribute('data-cy')) {
        cx = parseFloat(cono.getAttribute('data-cx'));
        cy = parseFloat(cono.getAttribute('data-cy'));
      } else {
        const d = cono.getAttribute('d');
        const puntos = d.split(' ');
        const primerPunto = puntos[0].replace('M', '').split(',');
        cx = parseFloat(primerPunto[0]) + 2.5;
        cy = parseFloat(primerPunto[1]) + 2.5;
      }
      cono.setAttribute('stroke-width', '0.8');
    }
    
    // Verificar si est√° en zona de descarte
    const enZonaDescarte = ZONAS_DESCARTE.some(zona => 
      cx >= zona.x && cx <= zona.x + zona.width &&
      cy >= zona.y && cy <= zona.y + zona.height
    );
    
    if (enZonaDescarte) {
      cono.remove();
      return;
    }
    
    // Determinar mejor posici√≥n para el texto (evitar solapamientos)
    const posicionesCandidatas = [
      { dx: 0, dy: -10, anchor: 'middle', baseline: 'baseline' },   // Arriba
      { dx: 12, dy: 0, anchor: 'start', baseline: 'middle' },       // Derecha
      { dx: 0, dy: 12, anchor: 'middle', baseline: 'hanging' },     // Abajo
      { dx: -12, dy: 0, anchor: 'end', baseline: 'middle' },        // Izquierda
      { dx: 10, dy: -10, anchor: 'start', baseline: 'baseline' },   // Arriba-derecha
      { dx: -10, dy: -10, anchor: 'end', baseline: 'baseline' },    // Arriba-izquierda
      { dx: 10, dy: 10, anchor: 'start', baseline: 'hanging' },     // Abajo-derecha
      { dx: -10, dy: 10, anchor: 'end', baseline: 'hanging' }       // Abajo-izquierda
    ];
    
    // Encontrar posici√≥n que no solape
    let posicionSeleccionada = null;
    for (const pos of posicionesCandidatas) {
      const textX = cx + pos.dx;
      const textY = cy + pos.dy;
      
      // Verificar si esta posici√≥n solapa con otros textos
      let solapa = false;
      for (const tp of textosPosiciones) {
        const distancia = Math.sqrt(Math.pow(textX - tp.x, 2) + Math.pow(textY - tp.y, 2));
        if (distancia < 8) { // Radio m√≠nimo de separaci√≥n
          solapa = true;
          break;
        }
      }
      
      if (!solapa) {
        posicionSeleccionada = { x: textX, y: textY, anchor: pos.anchor, baseline: pos.baseline };
        textosPosiciones.push({ x: textX, y: textY });
        break;
      }
    }
    
    // Si todas las posiciones solapan, usar la primera
    if (!posicionSeleccionada) {
      const pos = posicionesCandidatas[0];
      posicionSeleccionada = { 
        x: cx + pos.dx, 
        y: cy + pos.dy, 
        anchor: pos.anchor, 
        baseline: pos.baseline 
      };
      textosPosiciones.push({ x: cx + pos.dx, y: cy + pos.dy });
    }
    
    // A√±adir texto con el ID del cono
    const texto = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    texto.setAttribute('x', posicionSeleccionada.x);
    texto.setAttribute('y', posicionSeleccionada.y);
    texto.setAttribute('fill', '#000');
    texto.setAttribute('font-size', '6');
    texto.setAttribute('font-weight', 'bold');
    texto.setAttribute('text-anchor', posicionSeleccionada.anchor);
    texto.setAttribute('dominant-baseline', posicionSeleccionada.baseline);
    texto.textContent = id;
    
    // Insertar despu√©s del cono
    cono.parentNode.insertBefore(texto, cono.nextSibling);
  });
  
  // Tambi√©n eliminar elementos que no son conos identificables
  clone.querySelectorAll('circle:not([id]), path:not([id])').forEach(el => {
    if (el.getAttribute('fill') === 'deepskyblue' || 
        (el.tagName === 'path' && el.getAttribute('stroke') === 'black')) {
      el.remove();
    }
  });

  // Eliminar capas din√°micas (lineas, recorrido, numeros) para limpieza
  const capasAEliminar = ['lineas', 'recorrido', 'numeros'];
  capasAEliminar.forEach(id => {
    const capa = clone.querySelector(`#${id}`);
    if (capa) capa.remove();
  });

  clone.setAttribute('width', '200mm');
  clone.setAttribute('height', '400mm');
  clone.setAttribute('viewBox', '0 0 200 400');

  const xml = new XMLSerializer().serializeToString(clone);
  const blob = new Blob([xml], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${nombre}.svg`;
  
  // Mostrar confirmaci√≥n
  if (confirm(`¬øExportar mapa con TODOS los IDs de conos?\n\nArchivo: ${nombre}.svg\n\nEsto es √∫til para evaluaci√≥n de alumnos.`)) {
    a.click();
  }
  
  setTimeout(() => {
    URL.revokeObjectURL(url);
  }, 100);
}

// Inicializar
configurarConos();
actualizarCuadricula();

// Inicializar: si hay valores en inputs, actualizar recorrido
if (document.querySelectorAll('#camposConos input').some(i => i.value)) {
    actualizarRecorrido();
}

// Inicializar sistema de configuraciones guardadas
actualizarSelectorConfiguraciones();

</script>
</body>
</html>