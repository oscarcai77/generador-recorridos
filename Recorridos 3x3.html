<!--    BLOQUE 1: HTML + CSS principal
        BLOQUE 2: SVG con elementos fijos
        BLOQUE 3: JavaScript b√°sico (variables, listeners)
        BLOQUE 4: Funciones de actualizaci√≥n y dibujo
        BLOQUE 5: Recorrido aleatorio
        BLOQUE 6: Exportaci√≥n
-->


<!-- ******** INICIO BLOQUE 1 ******** -->
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Recorridos de orientaci√≥n ‚Äî Versi√≥n final</title>
<style>
  :root{ --violeta:#B03A94; --bg:#f7f7f9; --panel-bg:rgba(255,255,255,0.95) }
  body{
    font-family: "Segoe UI", sans-serif;
    margin:0;
    padding:1rem;
    display:flex;
    gap:1.5rem;
    align-items:flex-start;
    background: var(--bg);
  }
  #panel{
    width: 400px;
    background: var(--panel-bg);
    padding: 1.3rem;
    border-radius: 12px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
  }
  h2{ 
    margin: 0 0 0.9rem 0; 
    font-size: 1.3rem;
  }
  label{ 
    font-size: 1.1rem;
    margin-top: 0.9rem; 
    display: block;
  }
  input[type="text"], #listaConos, select { 
    width: 100%; 
    box-sizing: border-box; 
    padding: 9px 11px;
    margin-top: 8px;
    border-radius: 8px;
    border: 1px solid #ccc;
    font-size: 1.1rem;
  }
  .row { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
  .small { 
    padding: 9px 13px;
    font-size: 1.1rem;
    border-radius: 8px;
    border: 0;
    background: var(--violeta);
    color: #fff;
    cursor: pointer;
  }
  button{ 
    background: var(--violeta);
    color: #fff;
    border: 0;
    padding: 11px 15px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 1.1rem;
  }
  svg{ max-width:920px; width:100%; height:auto; border:1px solid #ccc; background:white; }
  .cono-pointer{ cursor:pointer }
  .cono-selected{ stroke:#000; stroke-width:0.9; fill-opacity:0.85; }
  hr{ border:0; border-top:1px solid #eee; margin:10px 0; }
</style>
</head>
<body>

  <div id="panel">
    <h2>Recorrido de orientaci√≥n</h2>
    <label>Introducir conos separados por comas</label>
    <input id="listaConos" placeholder="Ej: 42,39,58,62,33,40,52">
    <div class="row">
      <button class="small" onclick="aplicarLista()">Aplicar lista</button>
      <button class="small" onclick="borrarRecorrido()">Borrar recorrido</button>
      <button class="small" onclick="generarRecorridoAleatorio()" id="botonAleatorio">Recorrido aleatorio (7)</button>
      <button class="small" onclick="copiarNumerosRecorrido()">Copiar n√∫meros recorrido</button>
    </div>

    <label>Conos seleccionados (m√°x. 12) ‚Äî editable</label>
    <div id="camposConos" style="margin-top:6px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px;">
      <input id="id1" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id2" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id3" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id4" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id5" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id6" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id7" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id8" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id9" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id10" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id11" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
      <input id="id12" type="text" oninput="actualizarRecorrido()" style="font-size: 0.9rem; padding: 4px 6px;">
    </div>

    <label>Tri√°ngulo de inicio</label>
    <select id="trianguloInicio" onchange="actualizarRecorrido()">
      <option value="">Sin tri√°ngulo</option>
      <option value="A">A (Sur)</option>
      <option value="B">B (Oeste)</option>
      <option value="C">C (Norte)</option>
      <option value="D">D (Este)</option>
    </select>


    <!-- Control del fondo (mover la imagen) - EN DESPLEGABLE -->
    <details style="margin-top: 12px; padding: 8px; background: #f8f9fa; border-radius: 6px;">
      <summary style="cursor: pointer; font-weight: bold; padding: 4px; font-size: 1.5rem; display: flex; align-items: center; gap: 8px;">
        <span>üåÖ</span>
        <span>Ajustar fondo</span>
      </summary>

      <div class="row" style="margin-top:8px; align-items:center;">
        <label for="toggleFondo" style="margin:0">Mostrar fondo (Fondo_3x3.png/jpg/jpeg/gif/webp/svg/pdf)</label>
        <input id="toggleFondo" type="checkbox" disabled>      
      </div>
      
      <div style="margin: 8px 0; font-size: 0.9rem; color: #666;">
        Mueve y haz zoom en la imagen de fondo para alinearla con los conos
      </div>
      
      <div id="controlesFondo" style="margin:10px 0;">
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <label style="flex: 1; min-width: 100px;">Escala fondo:</label>
          <div style="display: flex; align-items: center; gap: 4px; flex: 2;">
            <button onclick="ajustarEscala(-0.01)" style="padding:4px 8px;">-</button>
            <input type="range" id="sliderEscalaFondo" min="0.1" max="5" step="0.001" value="1" style="flex: 1;">
            <button onclick="ajustarEscala(0.01)" style="padding:4px 8px;">+</button>
            <span id="valorEscalaFondo" style="min-width: 40px; text-align: center;">1x</span>
          </div>
        </div>
        
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <label style="flex: 1; min-width: 100px;">Desplazar X:</label>
          <div style="display: flex; align-items: center; gap: 4px; flex: 2;">
            <button onclick="ajustarPosicion('X', -1)" style="padding:4px 8px;">‚Üê</button>
            <input type="range" id="sliderXFondo" min="-400" max="400" step="0.5" value="0" style="flex: 1;">
            <button onclick="ajustarPosicion('X', 1)" style="padding:4px 8px;">‚Üí</button>
            <span id="valorXFondo" style="min-width: 40px; text-align: center;">0</span>
          </div>
        </div>
        
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <label style="flex: 1; min-width: 100px;">Desplazar Y:</label>
          <div style="display: flex; align-items: center; gap: 4px; flex: 2;">
            <button onclick="ajustarPosicion('Y', -1)" style="padding:4px 8px;">‚Üë</button>
            <input type="range" id="sliderYFondo" min="-400" max="400" step="0.5" value="0" style="flex: 1;">
            <button onclick="ajustarPosicion('Y', 1)" style="padding:4px 8px;">‚Üì</button>
            <span id="valorYFondo" style="min-width: 40px; text-align: center;">0</span>
          </div>
        </div>
        
        <div style="text-align: center; margin-top: 12px;">
          <button onclick="resetearFondo()" class="small" style="padding:6px 12px;">
            ‚Üª Resetear posici√≥n fondo
          </button>
        </div>
      </div>
    </details>    

    
    <!-- Panel de configuraci√≥n desplegable -->
    <details style="margin-top: 12px; padding: 8px; background: #f8f9fa; border-radius: 6px;">
      <summary style="cursor: pointer; font-weight: bold; padding: 4px; font-size: 1.5rem; display: flex; align-items: center; gap: 8px;">
        <span>‚öôÔ∏è</span>
        <span>Configuraci√≥n avanzada</span>
      </summary>
      
      <div style="margin-top: 8px;">
        <label>N√∫mero de puntos: <span id="valorPuntos">7</span></label>
        <input type="range" id="numeroPuntos" min="5" max="12" step="1" value="7" onchange="actualizarNumeroPuntos()" style="width: 100%;">
      </div>

      <div style="margin-top: 8px;">
        <label>Grosor l√≠neas (1.3): <span id="valorGrosor">1.3</span>mm</label>
        <input type="range" id="grosorLineas" min="0.5" max="2.5" step="0.1" value="1.3" onchange="actualizarConfiguracion()" style="width: 100%;">
      </div>
      
      <div style="margin-top: 8px;">
        <label>Grosor bordes conos (0.2): <span id="valorBordeConos">0.2</span>mm</label>
        <input type="range" id="grosorBordeConos" min="0.1" max="1" step="0.1" value="0.2" onchange="actualizarConfiguracion()" style="width: 100%;">
      </div>
      
      <div style="margin-top: 8px;">
        <label>Tama√±o conos (3.5): <span id="valorConos">3.5</span>mm</label>
        <input type="range" id="tamanoConos" min="2" max="6" step="0.5" value="3.5" onchange="actualizarConfiguracion()" style="width: 100%;">
      </div>
      
      <div style="margin-top: 8px;">
        <label>Radio c√≠rculos (8): <span id="valorOverlay">8</span>mm</label>
        <input type="range" id="radioOverlay" min="5" max="12" step="0.5" value="8" onchange="actualizarConfiguracion()" style="width: 100%;">
      </div>
      
      <div style="margin-top: 8px;">
        <label>Tama√±o texto n√∫meros (9): <span id="valorTexto">9</span>px</label>
        <input type="range" id="tamanoTexto" min="6" max="12" step="0.5" value="9" onchange="actualizarConfiguracion()" style="width: 100%;">
      </div>
            
      <!-- Selector de forma de conos -->
      <div style="margin-top: 8px;">
        <label>Forma de los conos: </label>
        <select id="formaConos" onchange="cambiarFormaConos()" style="width: 100%; padding: 6px; margin-top: 4px;">
          <option value="circulo">C√≠rculo</option>
          <option value="x">X</option>
        </select>
      </div>
    </details>
    
    <hr>

    <h2 style="margin-top:12px; font-size:1.2rem">Exportar a SVG</h2>
    <div class="row">
      <label>Nombre del recorrido</label>
      <input id="nombre" placeholder="Ej: Recorrido_A">  
      <button class="small" onclick="exportarSVG()">Exportar a SVG</button>
      <button class="small" onclick="exportarmediano()">SVG Mediano</button>
      <button class="small" onclick="exportarpeque()">SVG Peque√±o</button>
      <button class="small" onclick="exportarSVGConIDs3x3()">SVG con IDs</button>
    
    </div>
  </div>
<!-- ******** FIN BLOQUE 1 ******** -->

















<!-- ******** INICIO BLOQUE 2 ******** -->
  <!-- SVG con lienzo de 200x200mm -->
  <svg id="mapa" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200" width="800">
    <!-- Imagen de fondo dentro del SVG -->
    <g id="fondoGroup">
      <image id="bgImage" x="0" y="0" width="200" height="200" opacity="0.45" preserveAspectRatio="xMidYMid meet" />
    </g>

    
    <g id="fixed-layer">
      <!-- Doble c√≠rculo central - PROPORCIONAL -->
      <circle cx="100" cy="100" r="8" stroke="#B03A94" stroke-width="1.3" fill="none" id="circuloExterior"/>
      <circle cx="100" cy="100" r="5.4" stroke="#B03A94" stroke-width="1.3" fill="none" id="circuloInterior"/>

      <!-- Tri√°ngulos A-D -->
      <!-- Tri√°ngulo A (abajo) -->
      <polygon points="91.25,197.95 100,183.95 108.75,197.95" stroke="#B03A94" stroke-width="1.3" fill="none"/>
      <text x="97.5" y="195.5" font-size="7" font-weight="700" fill="#000">A</text>

      <!-- Tri√°ngulo B (izquierda) - GIRO 90¬∞ IZQUIERDA -->
      <polygon points="2.05,91.25 2.05,108.75 16.05,100" stroke="#B03A94" stroke-width="1.3" fill="none"/>
      <text x="4" y="101.7" font-size="7" font-weight="700" fill="#000">B</text>

      <!-- Tri√°ngulo C (arriba) -->
      <polygon points="91.25,2.05 108.75,2.05 100,16.05" stroke="#B03A94" stroke-width="1.3" fill="none"/>
      <text x="97.8" y="9.5" font-size="7" font-weight="700" fill="#000">C</text>

      <!-- Tri√°ngulo D (derecha) - GIRO 90¬∞ DERECHA -->
      <polygon points="197.95,91.25 183.95,100 197.95,108.75" stroke="#B03A94" stroke-width="1.3" fill="none"/>
      <text x="191.5" y="101.7" font-size="7" font-weight="700" fill="#000">D</text>

      <!-- Conos: Superior izquierdo -->
      <circle id="cono24" cx="25" cy="25" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono51" cx="45" cy="25" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono91" cx="65" cy="25" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono30" cx="25" cy="45" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono70" cx="45" cy="45" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono40" cx="65" cy="45" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono55" cx="25" cy="65" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono15" cx="45" cy="65" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono96" cx="65" cy="65" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>

      <!-- Conos: Superior derecho -->
      <circle id="cono29" cx="135" cy="25" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono79" cx="155" cy="25" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono62" cx="175" cy="25" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono45" cx="135" cy="45" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono18" cx="155" cy="45" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono85" cx="175" cy="45" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono68" cx="135" cy="65" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono39" cx="155" cy="65" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono33" cx="175" cy="65" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>

      <!-- Conos: Inferior izquierdo -->
      <circle id="cono27" cx="25" cy="135" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono82" cx="45" cy="135" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono59" cx="65" cy="135" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono48" cx="25" cy="155" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono13" cx="45" cy="155" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono89" cx="65" cy="155" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono71" cx="25" cy="175" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono37" cx="45" cy="175" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono22" cx="65" cy="175" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>

      <!-- Conos: Inferior derecho -->
      <circle id="cono31" cx="135" cy="135" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono76" cx="155" cy="135" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono64" cx="175" cy="135" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono52" cx="135" cy="155" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono11" cx="155" cy="155" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono94" cx="175" cy="155" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono73" cx="135" cy="175" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono43" cx="155" cy="175" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
      <circle id="cono87" cx="175" cy="175" r="3.5" fill="deepskyblue" stroke="black" stroke-width="0.2"/>
    </g>

    <!-- Capas din√°micas encima -->
    <g id="lineas"></g>
    <g id="recorrido"></g>
    <g id="numeros"></g>
  </svg>
<!-- ******** FIN BLOQUE 2 ******** -->



















// ******** INICIO BLOQUE 3 ********
<script>
// Variables globales para configuraci√≥n - VALORES ORIGINALES
let GROSOR_LINEAS = 1.3;
let GROSOR_BORDE_CONOS = 0.2;
let TAMANO_CONOS = 3.5;
let RADIO_OVERLAY = 8;
let TAMANO_TEXTO = 9;
let NUMERO_PUNTOS = 7;

// Variable para forma de conos
let FORMA_CONOS = 'circulo'; // 'circulo' o 'x'

// Funci√≥n para cambiar forma de conos
function cambiarFormaConos() {
  FORMA_CONOS = document.getElementById('formaConos').value;
  actualizarFormaConos();
  // Si hay recorrido, actualizar para que se vean los cambios
  if (Array.from(campos).slice(0, NUMERO_PUNTOS).some(campo => campo.value)) {
    actualizarRecorrido();
  }
}

/* --- Configurar listeners de conos (solo selecci√≥n, sin arrastre) --- */
function configurarConos() {
    document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(cono => {
        cono.classList.add('cono-pointer');

        // Eliminar listeners previos para evitar duplicados
        cono.removeEventListener('click', manejarClicCono);
        cono.addEventListener('click', manejarClicCono);
    });
}

/* --- Manejar clic sobre un cono --- */
function manejarClicCono(event) {
    const cono = event.target;
    const id = cono.id.replace('cono','');

    if(estaSeleccionado(id)) return;

    // Buscar primer campo vac√≠o visible
    const idx = campos.findIndex(c => !c.value && c.style.display !== 'none');
    if(idx === -1){
        alert('Ya has seleccionado todos los conos disponibles.');
        return;
    }

    campos[idx].value = id;
    actualizarRecorrido();
}


/* --- referencias --- */
const campos = Array.from({length:12}, (_,i)=>document.getElementById('id'+(i+1)));
const gLineas = document.getElementById('lineas');
const gRecorrido = document.getElementById('recorrido');
const gNumeros = document.getElementById('numeros');
const toggleFondo = document.getElementById('toggleFondo');
const bgImage = document.getElementById('bgImage');

// --- Control de fondo: posici√≥n y escala ---
const fondoGroup = document.getElementById('fondoGroup');
let scaleFondo = 1;
let offsetX = 0;
let offsetY = 0;

// Referencias a los controles del fondo
const sliderEscala = document.getElementById('sliderEscalaFondo');
const sliderX = document.getElementById('sliderXFondo');
const sliderY = document.getElementById('sliderYFondo');
const valorEscala = document.getElementById('valorEscalaFondo');
const valorX = document.getElementById('valorXFondo');
const valorY = document.getElementById('valorYFondo');

// Funci√≥n para actualizar la transformaci√≥n del fondo (versi√≥n mejorada)
function actualizarTransformFondo() {
    if(!fondoGroup) return;
    
    // Obtener valores actuales de los sliders
    const escala = sliderEscala ? parseFloat(sliderEscala.value) : 1;
    const desplazamientoX = sliderX ? parseFloat(sliderX.value) : 0;
    const desplazamientoY = sliderY ? parseFloat(sliderY.value) : 0;
    
    // Actualizar variables globales
    scaleFondo = escala;
    offsetX = desplazamientoX;
    offsetY = desplazamientoY;
    
    // Calcular transformaci√≥n: primero centrar, luego escalar, luego desplazar
    // Esto permite que el 0 est√© en el centro
    const centerX = 100; // Centro del SVG (200/2)
    const centerY = 100; // Centro del SVG (200/2)
    
    // Transformaci√≥n en 3 pasos:
    // 1. translate(-centerX, -centerY): mover al origen
    // 2. scale(escala): escalar
    // 3. translate(centerX + offsetX, centerY + offsetY): volver al centro + desplazamiento
    const transform = `
        translate(${centerX + offsetX}, ${centerY + offsetY}) 
        scale(${scaleFondo}) 
        translate(${-centerX}, ${-centerY})
    `;
    
    fondoGroup.setAttribute('transform', transform);
    
    // Actualizar valores visibles
    if(valorEscala) valorEscala.textContent = scaleFondo.toFixed(2);
    if(valorX) valorX.textContent = offsetX;
    if(valorY) valorY.textContent = offsetY;
}

// Asignar listeners a los sliders
if(sliderEscala) {
    sliderEscala.addEventListener('input', actualizarTransformFondo);
}
if(sliderX) {
    sliderX.addEventListener('input', actualizarTransformFondo);
}
if(sliderY) {
    sliderY.addEventListener('input', actualizarTransformFondo);
}

// Inicializar posici√≥n del fondo
actualizarTransformFondo();


/* --- buscar fondo.png/jpg y activar checkbox solo si existe --- */
(function probeBackground(){
  const formatos = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'pdf'];
  const baseName = 'Fondo_3x3';
  
  function test(src){
    return new Promise(res=>{
      const img = new Image();
      img.onload = ()=>res(src);
      img.onerror = ()=>res(null);
      img.src = src + '?_=' + Date.now();
    });
  }
  
  Promise.all(formatos.map(ext => test(`${baseName}.${ext}`))).then(results => {
    const found = results.find(src => src !== null);
    if(found){
      bgImage.setAttribute('href', found);
      bgImage.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      toggleFondo.disabled = false;
      toggleFondo.addEventListener('change', ()=> {
        bgImage.style.display = toggleFondo.checked ? 'block' : 'none';
      });
    } else {
      toggleFondo.disabled = true;
    }
  });
})();

/* --- ayuda: comprobar duplicado en campos --- */
function estaSeleccionado(id){ return campos.some(c => c.value === String(id)); }

/* --- aplicar lista de coma (bot√≥n) --- */
function aplicarLista(){
  const lista = document.getElementById('listaConos').value.trim();
  if(!lista) return;
  const valores = lista.split(',').map(s=>s.trim()).filter(Boolean).slice(0, NUMERO_PUNTOS);
  campos.forEach((c,i)=> c.value = valores[i] || '');
  actualizarRecorrido();
}

/* --- a√±adir listener a todos los conos de la capa fija (clic para seleccionar) --- */
document.querySelectorAll('#fixed-layer circle[id^="cono"]').forEach(cono=>{
  cono.classList.add('cono-pointer');
  cono.addEventListener('click', ()=>{
    const id = cono.id.replace('cono','');
    if(estaSeleccionado(id)) return;
    const idx = campos.findIndex(c => !c.value && c.style.display !== 'none');
    if(idx === -1){ alert('Ya has seleccionado los ' + NUMERO_PUNTOS + ' conos m√°ximos.'); return; }
    campos[idx].value = id;
    actualizarRecorrido();
  });
});

/* --- borrar recorrido y campos --- */
function borrarRecorrido(){
  campos.forEach(c=>c.value='');
  document.getElementById('trianguloInicio').value = '';
  gLineas.innerHTML = '';
  gRecorrido.innerHTML = '';
  gNumeros.innerHTML = '';
  document.querySelectorAll('#fixed-layer circle[id^="cono"]').forEach(c=>c.classList.remove('cono-selected'));
}

/* --- Copiar IDs de conos del recorrido al portapapeles --- */
function copiarNumerosRecorrido() {
    const ids = campos.map(c => c.value.trim()).filter(Boolean);
    if (ids.length === 0) {
        alert('No hay recorrido para copiar');
        return;
    }
    
    // Separar por tabs - funciona en Excel y Word
    const idsConos = ids.join('\t');
    
    // Copiar al portapapeles
    navigator.clipboard.writeText(idsConos)
        .then(() => {
            alert(`IDs copiados: ${ids.join(', ')}\n\nEn Excel: Se pegan en celdas horizontales\nEn Word: Se crea una tabla de una fila`);
        })
        .catch(err => {
            console.error('Error al copiar: ', err);
            // Fallback para navegadores antiguos
            const textArea = document.createElement('textarea');
            textArea.value = idsConos;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            alert(`IDs copiados: ${ids.join(', ')}\n\nEn Excel: Se pegan en celdas horizontales\nEn Word: Se crea una fila con tabulaciones`);
        });
}

/* --- Actualizar n√∫mero de puntos --- */
function actualizarNumeroPuntos() {
    NUMERO_PUNTOS = parseInt(document.getElementById('numeroPuntos').value);
    document.getElementById('valorPuntos').textContent = NUMERO_PUNTOS;
    
    // Mostrar/ocultar campos seg√∫n el n√∫mero seleccionado
    for (let i = 1; i <= 12; i++) {
        const campo = document.getElementById('id' + i);
        if (campo) {
            campo.style.display = i <= NUMERO_PUNTOS ? 'block' : 'none';
            if (i > NUMERO_PUNTOS) campo.value = ''; // Limpiar campos ocultos
        }
    }
    
    // Si hay valores en campos visibles, actualizar el recorrido
    if (Array.from(campos).slice(0, NUMERO_PUNTOS).some(campo => campo.value)) {
        actualizarRecorrido();
    }
    actualizarBotonAleatorio();
}

/* --- Actualizar texto del bot√≥n aleatorio --- */
function actualizarBotonAleatorio() {
    const boton = document.getElementById('botonAleatorio');
    if (boton) {
        boton.textContent = 'Recorrido aleatorio (' + NUMERO_PUNTOS + ')';
    }
}

// Funciones para ajuste fino del fondo
function ajustarEscala(delta) {
    if(!sliderEscala) return;
    let value = parseFloat(sliderEscala.value) + delta;
    // Limitar al rango
    value = Math.max(parseFloat(sliderEscala.min), Math.min(parseFloat(sliderEscala.max), value));
    sliderEscala.value = value.toFixed(3); // 3 decimales
    // Disparar evento de cambio
    sliderEscala.dispatchEvent(new Event('input'));
}

function ajustarPosicion(eje, delta) {
    const slider = document.getElementById('slider' + eje + 'Fondo');
    if(!slider) return;
    let value = parseFloat(slider.value) + delta;
    // Limitar al rango
    value = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), value));
    slider.value = value.toFixed(1); // 1 decimal
    // Disparar evento de cambio
    slider.dispatchEvent(new Event('input'));
}

function resetearFondo() {
    if(sliderEscala) sliderEscala.value = 1;
    if(sliderX) sliderX.value = 0;
    if(sliderY) sliderY.value = 0;
    actualizarTransformFondo();
}

// Inicializar bot√≥n al cargar la p√°gina
actualizarBotonAleatorio();

// Inicializar: configurar listeners de conos
configurarConos();

// ******** FIN BLOQUE 3 ********
















// ******** INICIO BLOQUE 4 ******** 

/* --- actualizar configuraci√≥n --- */
function actualizarConfiguracion() {
    GROSOR_LINEAS = parseFloat(document.getElementById('grosorLineas').value);
    GROSOR_BORDE_CONOS = parseFloat(document.getElementById('grosorBordeConos').value);
    TAMANO_CONOS = parseFloat(document.getElementById('tamanoConos').value);
    RADIO_OVERLAY = parseFloat(document.getElementById('radioOverlay').value);
    TAMANO_TEXTO = parseFloat(document.getElementById('tamanoTexto').value);

    document.getElementById('valorGrosor').textContent = GROSOR_LINEAS;
    document.getElementById('valorBordeConos').textContent = GROSOR_BORDE_CONOS;
    document.getElementById('valorConos').textContent = TAMANO_CONOS;
    document.getElementById('valorOverlay').textContent = RADIO_OVERLAY;
    document.getElementById('valorTexto').textContent = TAMANO_TEXTO;

    // ACTUALIZAR overlays del recorrido (c√≠rculos alrededor de conos seleccionados)
    document.querySelectorAll('#recorrido circle').forEach(circ => {
        circ.setAttribute('r', RADIO_OVERLAY);
        circ.setAttribute('stroke-width', GROSOR_LINEAS);
    });

    // ACTUALIZAR bordes de los conos (tanto c√≠rculos como X)
    document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(cono => {
        if (cono.tagName === 'circle') {
            // Actualizar c√≠rculos
            cono.setAttribute('r', TAMANO_CONOS);
            cono.setAttribute('stroke-width', GROSOR_BORDE_CONOS);
        } else if (cono.tagName === 'path' && FORMA_CONOS === 'x') {
            // Actualizar X - recrear con nuevo tama√±o
            const id = cono.id.replace('cono', '');
            const tama√±oX = TAMANO_CONOS * 0.7;
            
            // Obtener posici√≥n actual
            let cx, cy;
            if (cono.hasAttribute('data-cx') && cono.hasAttribute('data-cy')) {
                cx = parseFloat(cono.getAttribute('data-cx'));
                cy = parseFloat(cono.getAttribute('data-cy'));
            } else {
                const d = cono.getAttribute('d');
                const puntos = d.split(' ');
                const primerPunto = puntos[0].replace('M', '').split(',');
                cx = parseFloat(primerPunto[0]) + 2.5;
                cy = parseFloat(primerPunto[1]) + 2.5;
            }
            
            // Crear nueva X con tama√±o actualizado
            const nuevaX = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            nuevaX.id = 'cono' + id;
            nuevaX.setAttribute('d', `M${cx-tama√±oX},${cy-tama√±oX} L${cx+tama√±oX},${cy+tama√±oX} M${cx+tama√±oX},${cy-tama√±oX} L${cx-tama√±oX},${cy+tama√±oX}`);
            nuevaX.setAttribute('stroke', 'black');
            nuevaX.setAttribute('stroke-width', '0.8');
            nuevaX.setAttribute('stroke-linecap', 'round');
            nuevaX.setAttribute('fill', 'none');
            nuevaX.classList.add('cono-pointer');
            nuevaX.setAttribute('data-cx', cx);
            nuevaX.setAttribute('data-cy', cy);
            
            // Reemplazar la X antigua
            cono.parentNode.replaceChild(nuevaX, cono);
        }
    });

    // ACTUALIZAR tama√±o de texto de los n√∫meros
    document.querySelectorAll('#numeros text').forEach(texto => {
        texto.setAttribute('font-size', TAMANO_TEXTO);
    });

    const circuloExt = document.getElementById('circuloExterior');
    const circuloInt = document.getElementById('circuloInterior');
    if (circuloExt && circuloInt) {
        circuloExt.setAttribute('r', RADIO_OVERLAY);
        circuloInt.setAttribute('r', RADIO_OVERLAY * 0.67);
    }

    document.querySelectorAll('#fixed-layer [stroke="#B03A94"]').forEach(el => {
        el.setAttribute('stroke-width', GROSOR_LINEAS);
    });

    document.querySelectorAll('#lineas line').forEach(linea => {
        linea.setAttribute('stroke-width', GROSOR_LINEAS);
    });

    // SOLO actualizar recorrido si hay conos seleccionados y NO estamos en modo X
    const tieneRecorrido = Array.from(campos).slice(0, NUMERO_PUNTOS).some(campo => campo.value);
    if (tieneRecorrido && FORMA_CONOS === 'circulo') {
        // Guardar el estado actual
        const valoresActuales = campos.map(c => c.value);
        const trianguloActual = document.getElementById('trianguloInicio').value;
        
        // Limpiar temporalmente (esto activar√° actualizarRecorrido a trav√©s de los listeners)
        campos.forEach(c => c.value = '');
        
        // Restaurar inmediatamente en el siguiente ciclo de evento
        setTimeout(() => {
            campos.forEach((c, i) => {
                if (i < valoresActuales.length) c.value = valoresActuales[i];
            });
            document.getElementById('trianguloInicio').value = trianguloActual;
            // Forzar la actualizaci√≥n final
            actualizarRecorrido();
        }, 0);
    }
   configurarConos();
}

/* ------------------------------------------------------------- */
/*       FUNCI√ìN posicionNumero() con separaci√≥n DIFERENCIADA    */
/* ------------------------------------------------------------- */

// Mapa de posiciones reales de cada cono dentro de su cuadrante 3√ó3
// (0 a 8). Si un cono no est√° mapeado, se le asigna orientaci√≥n ‚Üë.
const mapaPosiciones = {
    // superior izquierdo
    24:0, 51:1, 91:2,
    30:3, 70:4, 40:5,
    55:6, 15:7, 96:8,

    // superior derecho
    29:0, 79:1, 62:2,
    45:3, 18:4, 85:5,
    68:6, 39:7, 33:8,

    // inferior izquierdo
    27:0, 82:1, 59:2,
    48:3, 13:4, 89:5,
    71:6, 37:7, 22:8,

    // inferior derecho
    31:0, 57:1, 44:2,
    61:3, 48:4, 36:5,
    40:6, 64:7, 52:8
};

// vectores direcci√≥n para cada posici√≥n 0‚Äì8
// ¬°OJO! POSICI√ìN 4 (centro) ‚Üí ‚Üó (0.7, -0.7)
const vectores = {
    0:{dx:-1, dy:-1}, // ‚Üñ
    1:{dx: 0, dy:-1}, // ‚Üë
    2:{dx: 1, dy:-1}, // ‚Üó
    3:{dx:-1, dy: 0}, // ‚Üê
    4:{dx: 0.7, dy:-0.7}, // ‚Üó (direcci√≥n especial del centro)
    5:{dx: 1, dy: 0}, // ‚Üí
    6:{dx:-1, dy: 1}, // ‚Üô
    7:{dx: 0, dy: 1}, // ‚Üì
    8:{dx: 1, dy: 1}  // ‚Üò
};

function posicionNumero(conoId) {
    const id = Number(conoId);
    const pos = mapaPosiciones[id] ?? 1;

    const v = vectores[pos];

    // SEPARACI√ìN ESPEC√çFICA - AUMENTAR PARA POSICI√ìN 6 y 7
    const factoresSeparacion = {
        0: 1.0, // ‚Üñ - normal
        1: 1.0, // ‚Üë - normal  
        2: 1.0, // ‚Üó - normal
        3: 1.0, // ‚Üê - normal
        4: 1.0, // ‚Üó - normal (centro especial)
        5: 1.0, // ‚Üí - normal
        6: 1.2, // ‚Üô - 20% m√°s de separaci√≥n para evitar que toque
        7: 1.3, // ‚Üì - 30% m√°s de separaci√≥n para el cono abajo-centro
        8: 1.0  // ‚Üò - normal
    };

    const factor = factoresSeparacion[pos] || 1.0;
    const SEPARACION = ((RADIO_OVERLAY * 0.18) + (TAMANO_TEXTO * 0.38)) * factor;

    // normalizaci√≥n de vectores diagonales
    const norm = Math.hypot(v.dx, v.dy) || 1;
    const dx = (RADIO_OVERLAY + SEPARACION) * (v.dx / norm);
    const dy = (RADIO_OVERLAY + SEPARACION) * (v.dy / norm);

    return {dx, dy};
}

/* ------------------------------------------------------------- */
/*               FUNCI√ìN PRINCIPAL: actualizarRecorrido()        */
/* ------------------------------------------------------------- */

function actualizarRecorrido(){
    gLineas.innerHTML = '';
    gRecorrido.innerHTML = '';
    gNumeros.innerHTML = '';

    document.querySelectorAll('#fixed-layer circle[id^="cono"]').forEach(c=>
        c.classList.remove('cono-selected')
    );

    const ids = campos.map(c=>c.value.trim()).filter(Boolean);

   const coords = ids.map(id=>{
        const el = document.getElementById('cono'+id);
        if(!el) return null;
        
        let x, y;
        
        if (el.tagName === 'circle') {
            // Si es c√≠rculo, obtener cx y cy directamente
            x = parseFloat(el.getAttribute('cx'));
            y = parseFloat(el.getAttribute('cy'));
        } else if (el.tagName === 'path') {
            // Si es path (X), usar data-cx y data-cy o calcular desde 'd'
            if (el.hasAttribute('data-cx') && el.hasAttribute('data-cy')) {
                x = parseFloat(el.getAttribute('data-cx'));
                y = parseFloat(el.getAttribute('data-cy'));
            } else {
                const d = el.getAttribute('d');
                const puntos = d.split(' ');
                const primerPunto = puntos[0].replace('M', '').split(',');
                x = parseFloat(primerPunto[0]) + 2.5;
                y = parseFloat(primerPunto[1]) + 2.5;
            }
        }
        
        return {
            id,
            x: x,
            y: y
        };
    }).filter(Boolean);


    // ----------- DIBUJO DE OVERLAYS Y N√öMEROS -------------
    coords.forEach((p,i)=>{
        const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circ.setAttribute('cx', p.x);
        circ.setAttribute('cy', p.y);
        circ.setAttribute('r', RADIO_OVERLAY);
        circ.setAttribute('stroke', '#B03A94');
        circ.setAttribute('fill', 'none');
        circ.setAttribute('stroke-width', GROSOR_LINEAS);
        gRecorrido.appendChild(circ);

        const {dx, dy} = posicionNumero(p.id);

        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.setAttribute('x', p.x + dx);
        txt.setAttribute('y', p.y + dy);
        txt.setAttribute('fill', '#B03A94');
        txt.setAttribute('font-size', TAMANO_TEXTO);
        txt.setAttribute('font-weight', '700');
        txt.setAttribute('text-anchor', 'middle');
        txt.setAttribute('dominant-baseline', 'middle');
        txt.textContent = String(i+1);
        gNumeros.appendChild(txt);

        const base = document.getElementById('cono'+p.id);
        if(base) base.classList.add('cono-selected');
    });


    // -------- L√çNEA DESDE TRI√ÅNGULO DE INICIO ------------
    const tri = document.getElementById('trianguloInicio').value;
    if(tri && coords.length > 0){
        let pTri;
        switch(tri){
            case 'A': pTri={x:100,y:183.95}; break; // Punta del tri√°ngulo A (hacia arriba/centro)
            case 'B': pTri={x:16.05,y:100}; break;  // Punta del tri√°ngulo B (hacia derecha/centro)
            case 'C': pTri={x:100,y:16.05}; break;  // Punta del tri√°ngulo C (hacia abajo/centro)
            case 'D': pTri={x:183.95,y:100}; break; // Punta del tri√°ngulo D (hacia izquierda/centro)
        }

        const first = coords[0];
        const dx = first.x - pTri.x;
        const dy = first.y - pTri.y;
        const d = Math.hypot(dx,dy) || 1;

        const x2 = first.x - (RADIO_OVERLAY * dx / d);
        const y2 = first.y - (RADIO_OVERLAY * dy / d);

        const l = document.createElementNS('http://www.w3.org/2000/svg','line');
        l.setAttribute('x1', pTri.x);
        l.setAttribute('y1', pTri.y);
        l.setAttribute('x2', x2);
        l.setAttribute('y2', y2);
        l.setAttribute('stroke', '#B03A94');
        l.setAttribute('stroke-width', GROSOR_LINEAS);
        l.setAttribute('stroke-linecap','round');
        gLineas.appendChild(l);
    }


    // ------------- L√çNEAS ENTRE CONOS ----------------
    for(let i=0;i<coords.length-1;i++){
        const a = coords[i], b = coords[i+1];
        const dx = b.x-a.x, dy = b.y-a.y;
        const d = Math.hypot(dx,dy) || 1;

        const ox = RADIO_OVERLAY * dx/d;
        const oy = RADIO_OVERLAY * dy/d;

        const x1 = a.x + ox;
        const y1 = a.y + oy;
        const x2 = b.x - ox;
        const y2 = b.y - oy;

        const l = document.createElementNS('http://www.w3.org/2000/svg','line');
        l.setAttribute('x1', x1);
        l.setAttribute('y1', y1);
        l.setAttribute('x2', x2);
        l.setAttribute('y2', y2);
        l.setAttribute('stroke', '#B03A94');
        l.setAttribute('stroke-width', GROSOR_LINEAS);
        l.setAttribute('stroke-linecap','round');
        gLineas.appendChild(l);
    }


    // --------- L√çNEA FINAL HACIA EL C√çRCULO CENTRAL ----------
    if(coords.length > 0){
        const last = coords[coords.length-1];
        const cx=100, cy=100;
        const dx=cx-last.x, dy=cy-last.y;
        const d=Math.hypot(dx,dy) || 1;

        const x1 = last.x + (RADIO_OVERLAY * dx/d);
        const y1 = last.y + (RADIO_OVERLAY * dy/d);
        const x2 = cx - (RADIO_OVERLAY * dx/d); // Termina en el c√≠rculo exterior
        const y2 = cy - (RADIO_OVERLAY * dy/d); // Termina en el c√≠rculo exterior

        const lf = document.createElementNS('http://www.w3.org/2000/svg','line');
        lf.setAttribute('x1', x1);
        lf.setAttribute('y1', y1);
        lf.setAttribute('x2', x2);
        lf.setAttribute('y2', y2);
        lf.setAttribute('stroke', '#B03A94');
        lf.setAttribute('stroke-width', GROSOR_LINEAS);
        lf.setAttribute('stroke-linecap','round');
        gLineas.appendChild(lf);
    }
}

/* --- Actualizar forma visual de todos los conos --- */
function actualizarFormaConos() {
  // Guardar las posiciones de TODOS los conos antes de cambiar
  const posiciones = [];
  
  document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(cono => {
    const id = cono.id.replace('cono', '');
    
    // Obtener posici√≥n actual (tanto para c√≠rculos como para paths)
    let cx, cy;
    
    if (cono.tagName === 'circle') {
      // Si es c√≠rculo, obtener cx y cy directamente
      cx = cono.getAttribute('cx');
      cy = cono.getAttribute('cy');
    } else if (cono.tagName === 'path') {
      // Si es path (X), usar los atributos data-cx y data-cy guardados
      cx = cono.getAttribute('data-cx');
      cy = cono.getAttribute('data-cy');
      // Si no existen, calcular desde el atributo 'd'
      if (!cx || !cy) {
        const d = cono.getAttribute('d');
        const puntos = d.split(' ');
        const primerPunto = puntos[0].replace('M', '').split(',');
        cx = parseFloat(primerPunto[0]) + 2.5; // Usar el tama√±o fijo
        cy = parseFloat(primerPunto[1]) + 2.5;
      }
    }
    
    posiciones.push({id, cx, cy});
  });
  
  // Limpiar y recrear TODOS los conos
  const fixedLayer = document.getElementById('fixed-layer');
  
  // Eliminar todos los conos actuales
  document.querySelectorAll('#fixed-layer [id^="cono"]').forEach(cono => {
    cono.remove();
  });
  
  // Crear todos los conos nuevos con la forma seleccionada
  posiciones.forEach(({id, cx, cy}) => {
    const nuevoCono = FORMA_CONOS === 'x' 
      ? crearConoX(id, cx, cy)
      : crearConoCirculo(id, cx, cy);
    
    fixedLayer.appendChild(nuevoCono);
  });
  
  // Reconfigurar listeners
  configurarConos();
}

/* --- Crear cono tipo X --- */
function crearConoX(id, cx, cy) {
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.id = 'cono' + id;
  const x = parseFloat(cx);
  const y = parseFloat(cy);
  
  // X con tama√±o FIJO (no depende de TAMANO_CONOS que puede cambiar)
  const tama√±oFijo = 2.5; // Tama√±o fijo para las X
  path.setAttribute('d', `M${x-tama√±oFijo},${y-tama√±oFijo} L${x+tama√±oFijo},${y+tama√±oFijo} M${x+tama√±oFijo},${y-tama√±oFijo} L${x-tama√±oFijo},${y+tama√±oFijo}`);
  path.setAttribute('stroke', 'black');
  path.setAttribute('stroke-width', '0.8');
  path.setAttribute('stroke-linecap', 'round');
  path.setAttribute('fill', 'none');
  path.classList.add('cono-pointer');
  
  // Guardar las coordenadas originales como atributos personalizados
  path.setAttribute('data-cx', x);
  path.setAttribute('data-cy', y);
  
  return path;
}

/* --- Crear cono tipo c√≠rculo --- */
function crearConoCirculo(id, cx, cy) {
  const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  circle.id = 'cono' + id;
  circle.setAttribute('cx', cx);
  circle.setAttribute('cy', cy);
  circle.setAttribute('r', TAMANO_CONOS);
  circle.setAttribute('fill', 'deepskyblue');
  circle.setAttribute('stroke', 'black');
  circle.setAttribute('stroke-width', '0.2');
  circle.classList.add('cono-pointer');
  return circle;
}
// ******** FIN BLOQUE 4 ******** 















// ******** INICIO BLOQUE 5 ********
/* --- Generar recorrido aleatorio adaptado (3x3) --- */
function generarRecorridoAleatorio() {
  // Definir cuadrantes y sus conos
  const cuadrantes = {
    superiorIzquierdo: [24, 51, 91, 30, 70, 40, 55, 15, 96],
    superiorDerecho: [29, 79, 62, 45, 18, 85, 68, 39, 33],
    inferiorIzquierdo: [27, 82, 59, 48, 13, 89, 71, 37, 22],
    inferiorDerecho: [31, 76, 64, 52, 11, 94, 73, 43, 87]
  };
  
  // Mapeo de posiciones dentro de cada cuadrante (3x3 grid)
  const posiciones = {
    0: [0, 0], // esquina superior izquierda
    1: [1, 0], // centro superior
    2: [2, 0], // esquina superior derecha
    3: [0, 1], // centro izquierda
    4: [1, 1], // centro
    5: [2, 1], // centro derecha
    6: [0, 2], // esquina inferior izquierda
    7: [1, 2], // centro inferior
    8: [2, 2]  // esquina inferior derecha
  };

  // Funci√≥n para verificar si dos posiciones son adyacentes
  function sonAdyacentes(pos1, pos2) {
    const [x1, y1] = posiciones[pos1];
    const [x2, y2] = posiciones[pos2];
    return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1;
  }

  let conosSeleccionados = [];
  let posicionesUsadas = {
    superiorIzquierdo: new Set(),
    superiorDerecho: new Set(),
    inferiorIzquierdo: new Set(),
    inferiorDerecho: new Set()
  };

  // PRIMERO: Garantizar al menos 1 cono de cada cuadrante
  Object.keys(cuadrantes).forEach(cuadrante => {
    const conosDisponibles = [...cuadrantes[cuadrante]];
    
    // Mezclar array aleatoriamente
    for (let i = conosDisponibles.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [conosDisponibles[i], conosDisponibles[j]] = [conosDisponibles[j], conosDisponibles[i]];
    }
    
    // Seleccionar al menos 1 cono de este cuadrante
    if (conosDisponibles.length > 0) {
      const conoSeleccionado = conosDisponibles[0];
      const posicionCono = cuadrantes[cuadrante].indexOf(conoSeleccionado);
      
      conosSeleccionados.push(conoSeleccionado);
      posicionesUsadas[cuadrante].add(posicionCono);
      
      // Remover el cono seleccionado de disponibles
      conosDisponibles.shift();
    }
  });

  // SEGUNDO: Completar hasta NUMERO_PUNTOS conos m√°ximo (distribuyendo entre cuadrantes)
  const cuadrantesArray = Object.keys(cuadrantes);
  let totalConos = conosSeleccionados.length;
  
  while (totalConos < NUMERO_PUNTOS && cuadrantesArray.some(c => cuadrantes[c].length > 0)) {
    // Seleccionar cuadrante aleatorio para a√±adir otro cono
    const cuadranteAleatorio = cuadrantesArray[Math.floor(Math.random() * cuadrantesArray.length)];
    const conosDisponiblesEnCuadrante = [...cuadrantes[cuadranteAleatorio]].filter(cono => 
      !conosSeleccionados.includes(cono)
    );
    
    if (conosDisponiblesEnCuadrante.length > 0) {
      // Mezclar disponibles
      for (let i = conosDisponiblesEnCuadrante.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [conosDisponiblesEnCuadrante[i], conosDisponiblesEnCuadrante[j]] = 
        [conosDisponiblesEnCuadrante[j], conosDisponiblesEnCuadrante[i]];
      }
      
      let conoValido = false;
      let intentos = 0;
      
      while (!conoValido && intentos < conosDisponiblesEnCuadrante.length) {
        const conoAleatorio = conosDisponiblesEnCuadrante[intentos];
        const posicionCono = cuadrantes[cuadranteAleatorio].indexOf(conoAleatorio);
        
        // Verificar que no sea adyacente a ning√∫n cono ya seleccionado en este cuadrante
        const esAdyacente = Array.from(posicionesUsadas[cuadranteAleatorio]).some(posicionExistente => {
          return sonAdyacentes(posicionCono, posicionExistente);
        });
        
        if (!esAdyacente) {
          conosSeleccionados.push(conoAleatorio);
          posicionesUsadas[cuadranteAleatorio].add(posicionCono);
          conoValido = true;
          totalConos++;
        } else {
          intentos++;
        }
      }
    }
  }

  // Mezclar el orden final de los conos
  for (let i = conosSeleccionados.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [conosSeleccionados[i], conosSeleccionados[j]] = [conosSeleccionados[j], conosSeleccionados[i]];
  }
  
  // Limitar a m√°ximo NUMERO_PUNTOS conos
  conosSeleccionados = conosSeleccionados.slice(0, NUMERO_PUNTOS);

  // Aplicar a los campos
  campos.forEach((campo, index) => {
    campo.value = conosSeleccionados[index] || '';
  });

  // Seleccionar tri√°ngulo de inicio aleatorio
  const triangulos = ['A', 'B', 'C', 'D'];
  const trianguloAleatorio = triangulos[Math.floor(Math.random() * triangulos.length)];
  document.getElementById('trianguloInicio').value = trianguloAleatorio;

  actualizarRecorrido();
}
// ******** FIN BLOQUE 5 ********










// ******** INICIO BLOQUE 6 ********
// Tama√±o del mapa 3x3 (en mm)
const MAP_SIZE = 200;

/* --- Exportar SVG - TAMA√ëO FIJO 200mm --- */
function exportarSVG(){
  const nombreInput = document.getElementById('nombre').value.trim();
  const nombre = nombreInput ? nombreInput : 'recorrido';
  const original = document.getElementById('mapa');
  const clone = original.cloneNode(true);

  // eliminar cualquier elemento marcado data-noexport (ej. image de fondo)
  clone.querySelectorAll('[data-noexport="true"]').forEach(n => n.remove());

  // Aplicar GROSOR_BORDE_CONOS actual a los conos en la exportaci√≥n
  clone.querySelectorAll('circle[id^="cono"]').forEach(cono => {
    cono.setAttribute('stroke-width', GROSOR_BORDE_CONOS);
  });

  // Tama√±o fijo 200mm - SIN ESCALADO
  clone.setAttribute('width', '200mm');
  clone.setAttribute('height', '200mm');
  clone.setAttribute('viewBox', '0 0 200 200');

  const xml = new XMLSerializer().serializeToString(clone);
  const blob = new Blob([xml], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${nombre}.svg`;
  a.click();
  URL.revokeObjectURL(url);
}

/* --- Exportar SVG al 61% con recalculo completo --- */
function exportarmediano() {
    const SCALE = 0.61;

    const nombreInput = document.getElementById('nombre').value.trim();
    const nombre = nombreInput ? nombreInput + "_61" : "recorrido_61";

    const original = document.getElementById('mapa');

    const svgNS = "http://www.w3.org/2000/svg";
    const nuevo = document.createElementNS(svgNS, "svg");

    nuevo.setAttribute("width", (200 * SCALE) + "mm");
    nuevo.setAttribute("height", (200 * SCALE) + "mm");
    nuevo.setAttribute("viewBox", `0 0 ${200 * SCALE} ${200 * SCALE}`);

    function esc(n) { return parseFloat(n) * SCALE; }

    function copiarNodo(nodo, destinoPadre) {
        if (nodo.nodeType === 3) return;

        const clon = document.createElementNS(svgNS, nodo.nodeName);

        for (const attr of nodo.attributes || []) {
            let name = attr.name;
            let val = attr.value;

            if (name === "data-noexport") return;

            if (["cx","cy","x","y","r","x1","y1","x2","y2"].includes(name)) {
                clon.setAttribute(name, esc(val));
                continue;
            }

            if (name === "stroke-width") {
                // Para conos, usar GROSOR_BORDE_CONOS actual en lugar del valor fijo
                if (nodo.id && nodo.id.startsWith("cono")) {
                    clon.setAttribute(name, esc(GROSOR_BORDE_CONOS));
                } else {
                    clon.setAttribute(name, esc(val));
                }
                continue;
            }

            if (name === "font-size") {
                clon.setAttribute(name, esc(val));
                continue;
            }

            if (name === "points") {
                const puntos = val.trim().split(" ").map(par => {
                    const [px, py] = par.split(",");
                    return esc(px) + "," + esc(py);
                });
                clon.setAttribute("points", puntos.join(" "));
                continue;
            }

            clon.setAttribute(name, val);
        }

        if (nodo.textContent && nodo.children.length === 0) {
            clon.textContent = nodo.textContent;
        }

        destinoPadre.appendChild(clon);

        for (const hijo of nodo.children) copiarNodo(hijo, clon);
    }

    const capas = ["fixed-layer", "lineas", "recorrido", "numeros"];

    capas.forEach(id => {
        const originalCapa = original.querySelector("#" + id);
        if (!originalCapa) return;

        const nuevaCapa = document.createElementNS(svgNS, "g");
        nuevaCapa.setAttribute("id", id);

        for (const nodo of originalCapa.children) {
            copiarNodo(nodo, nuevaCapa);
        }
        nuevo.appendChild(nuevaCapa);
    });

    const xml = new XMLSerializer().serializeToString(nuevo);
    const blob = new Blob([xml], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = nombre + ".svg";
    a.click();

    URL.revokeObjectURL(url);
}
/* --- Exportar SVG al 40% con recalculo completo --- */
function exportarpeque() {
    const SCALE = 0.26;

    const nombreInput = document.getElementById('nombre').value.trim();
    const nombre = nombreInput ? nombreInput + "_40" : "recorrido_40";

    const original = document.getElementById('mapa');

    const svgNS = "http://www.w3.org/2000/svg";
    const nuevo = document.createElementNS(svgNS, "svg");

    nuevo.setAttribute("width", (200 * SCALE) + "mm");
    nuevo.setAttribute("height", (200 * SCALE) + "mm");
    nuevo.setAttribute("viewBox", `0 0 ${200 * SCALE} ${200 * SCALE}`);

    function esc(n) { return parseFloat(n) * SCALE; }

    function copiarNodo(nodo, destinoPadre) {
        if (nodo.nodeType === 3) return;

        const clon = document.createElementNS(svgNS, nodo.nodeName);

        for (const attr of nodo.attributes || []) {
            let name = attr.name;
            let val = attr.value;

            if (name === "data-noexport") return;

            if (["cx","cy","x","y","r","x1","y1","x2","y2"].includes(name)) {
                clon.setAttribute(name, esc(val));
                continue;
            }

            if (name === "stroke-width") {
                if (nodo.id && nodo.id.startsWith("cono")) {
                    clon.setAttribute(name, esc(GROSOR_BORDE_CONOS));
                } else {
                    clon.setAttribute(name, esc(val));
                }
                continue;
            }

            if (name === "font-size") {
                clon.setAttribute(name, esc(val));
                continue;
            }

            if (name === "points") {
                const puntos = val.trim().split(" ").map(par => {
                    const [px, py] = par.split(",");
                    return esc(px) + "," + esc(py);
                });
                clon.setAttribute("points", puntos.join(" "));
                continue;
            }

            clon.setAttribute(name, val);
        }

        if (nodo.textContent && nodo.children.length === 0) {
            clon.textContent = nodo.textContent;
        }

        destinoPadre.appendChild(clon);

        for (const hijo of nodo.children) copiarNodo(hijo, clon);
    }

    const capas = ["fixed-layer", "lineas", "recorrido", "numeros"];

    capas.forEach(id => {
        const originalCapa = original.querySelector("#" + id);
        if (!originalCapa) return;

        const nuevaCapa = document.createElementNS(svgNS, "g");
        nuevaCapa.setAttribute("id", id);

        for (const nodo of originalCapa.children) {
            copiarNodo(nodo, nuevaCapa);
        }
        nuevo.appendChild(nuevaCapa);
    });

    const xml = new XMLSerializer().serializeToString(nuevo);
    const blob = new Blob([xml], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = nombre + ".svg";
    a.click();

    URL.revokeObjectURL(url);
}

/* --- Exportar SVG con TODOS los IDs de conos (3x3 para evaluaci√≥n) --- */
function exportarSVGConIDs3x3() {
  const nombreInput = document.getElementById('nombre').value.trim();
  const nombre = nombreInput ? nombreInput + "_todosIDs" : "recorrido3x3_todosIDs";
  const original = document.getElementById('mapa');
  const clone = original.cloneNode(true);
  
  // Eliminar elementos no exportables
  clone.querySelectorAll('[data-noexport="true"]').forEach(n => n.remove());
  
  // Array para almacenar posiciones de textos y evitar solapamientos
  const textosPosiciones = [];
  
  // Procesar TODOS los conos
  clone.querySelectorAll('[id^="cono"]').forEach(cono => {
    const id = cono.id.replace('cono', '');
    
    // Obtener posici√≥n del cono
    let cx, cy;
    
    if (cono.tagName === 'circle') {
      cx = parseFloat(cono.getAttribute('cx'));
      cy = parseFloat(cono.getAttribute('cy'));
      cono.setAttribute('stroke-width', GROSOR_BORDE_CONOS);
    } else if (cono.tagName === 'path') {
      // Para X, obtener posici√≥n desde data-* o calcular
      if (cono.hasAttribute('data-cx') && cono.hasAttribute('data-cy')) {
        cx = parseFloat(cono.getAttribute('data-cx'));
        cy = parseFloat(cono.getAttribute('data-cy'));
      } else {
        const d = cono.getAttribute('d');
        const puntos = d.split(' ');
        const primerPunto = puntos[0].replace('M', '').split(',');
        cx = parseFloat(primerPunto[0]) + 2.5;
        cy = parseFloat(primerPunto[1]) + 2.5;
      }
      cono.setAttribute('stroke-width', '0.8');
    }
    
    // Determinar mejor posici√≥n para el texto (evitar solapamientos)
    const posicionesCandidatas = [
      { dx: 0, dy: -10, anchor: 'middle', baseline: 'baseline' },   // Arriba
      { dx: 12, dy: 0, anchor: 'start', baseline: 'middle' },       // Derecha
      { dx: 0, dy: 12, anchor: 'middle', baseline: 'hanging' },     // Abajo
      { dx: -12, dy: 0, anchor: 'end', baseline: 'middle' },        // Izquierda
      { dx: 10, dy: -10, anchor: 'start', baseline: 'baseline' },   // Arriba-derecha
      { dx: -10, dy: -10, anchor: 'end', baseline: 'baseline' },    // Arriba-izquierda
      { dx: 10, dy: 10, anchor: 'start', baseline: 'hanging' },     // Abajo-derecha
      { dx: -10, dy: 10, anchor: 'end', baseline: 'hanging' }       // Abajo-izquierda
    ];
    
    // Encontrar posici√≥n que no solape
    let posicionSeleccionada = null;
    for (const pos of posicionesCandidatas) {
      const textX = cx + pos.dx;
      const textY = cy + pos.dy;
      
      // Verificar si esta posici√≥n solapa con otros textos
      let solapa = false;
      for (const tp of textosPosiciones) {
        const distancia = Math.sqrt(Math.pow(textX - tp.x, 2) + Math.pow(textY - tp.y, 2));
        if (distancia < 8) { // Radio m√≠nimo de separaci√≥n
          solapa = true;
          break;
        }
      }
      
      if (!solapa) {
        posicionSeleccionada = { x: textX, y: textY, anchor: pos.anchor, baseline: pos.baseline };
        textosPosiciones.push({ x: textX, y: textY });
        break;
      }
    }
    
    // Si todas las posiciones solapan, usar la primera
    if (!posicionSeleccionada) {
      const pos = posicionesCandidatas[0];
      posicionSeleccionada = { 
        x: cx + pos.dx, 
        y: cy + pos.dy, 
        anchor: pos.anchor, 
        baseline: pos.baseline 
      };
      textosPosiciones.push({ x: cx + pos.dx, y: cy + pos.dy });
    }
    
    // A√±adir texto con el ID del cono
    const texto = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    texto.setAttribute('x', posicionSeleccionada.x);
    texto.setAttribute('y', posicionSeleccionada.y);
    texto.setAttribute('fill', '#000');
    texto.setAttribute('font-size', '6');
    texto.setAttribute('font-weight', 'bold');
    texto.setAttribute('text-anchor', posicionSeleccionada.anchor);
    texto.setAttribute('dominant-baseline', posicionSeleccionada.baseline);
    texto.textContent = id;
    
    // Insertar despu√©s del cono
    cono.parentNode.insertBefore(texto, cono.nextSibling);
  });
  
  // Eliminar capas din√°micas (lineas, recorrido, numeros) para limpieza
  const capasAEliminar = ['lineas', 'recorrido', 'numeros'];
  capasAEliminar.forEach(id => {
    const capa = clone.querySelector(`#${id}`);
    if (capa) capa.remove();
  });

  clone.setAttribute('width', '200mm');
  clone.setAttribute('height', '200mm');
  clone.setAttribute('viewBox', '0 0 200 200');

  const xml = new XMLSerializer().serializeToString(clone);
  const blob = new Blob([xml], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${nombre}.svg`;
  
  // Mostrar confirmaci√≥n
  if (confirm(`¬øExportar mapa 3x3 con TODOS los IDs de conos?\n\nArchivo: ${nombre}.svg\n\nEsto es √∫til para evaluaci√≥n de alumnos.`)) {
    a.click();
  }
  
  setTimeout(() => {
    URL.revokeObjectURL(url);
  }, 100);
}

// Inicializar: si hay valores en inputs, actualizar recorrido
if (document.querySelectorAll('#camposConos input').some(i => i.value)) {
    actualizarRecorrido();
}
</script>
</body>
</html>